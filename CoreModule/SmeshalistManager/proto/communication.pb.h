// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: communication.proto

#ifndef PROTOBUF_communication_2eproto__INCLUDED
#define PROTOBUF_communication_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace sm {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_communication_2eproto();
void protobuf_AssignDesc_communication_2eproto();
void protobuf_ShutdownFile_communication_2eproto();

class BoundingBox;
class CoordinatesCondition;
class CoordinatesFilter;
class CoreToManagerMessage;
class ElementInfo;
class ElementsCount;
class GroupsFilter;
class GroupsInfo;
class ManagerToCoreMessage;
class OptionsInfo;
class QualityCondition;
class QualityFilter;
class StatisticsInfo;
class TypesFilter;

enum CoreToManagerMessage_CTMMessageType {
  CoreToManagerMessage_CTMMessageType_STATISTICS = 1,
  CoreToManagerMessage_CTMMessageType_BREAKPOINT = 2
};
bool CoreToManagerMessage_CTMMessageType_IsValid(int value);
const CoreToManagerMessage_CTMMessageType CoreToManagerMessage_CTMMessageType_CTMMessageType_MIN = CoreToManagerMessage_CTMMessageType_STATISTICS;
const CoreToManagerMessage_CTMMessageType CoreToManagerMessage_CTMMessageType_CTMMessageType_MAX = CoreToManagerMessage_CTMMessageType_BREAKPOINT;
const int CoreToManagerMessage_CTMMessageType_CTMMessageType_ARRAYSIZE = CoreToManagerMessage_CTMMessageType_CTMMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CoreToManagerMessage_CTMMessageType_descriptor();
inline const ::std::string& CoreToManagerMessage_CTMMessageType_Name(CoreToManagerMessage_CTMMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CoreToManagerMessage_CTMMessageType_descriptor(), value);
}
inline bool CoreToManagerMessage_CTMMessageType_Parse(
    const ::std::string& name, CoreToManagerMessage_CTMMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoreToManagerMessage_CTMMessageType>(
    CoreToManagerMessage_CTMMessageType_descriptor(), name, value);
}
enum CoordinatesFilter_Conjunction {
  CoordinatesFilter_Conjunction_AND = 1,
  CoordinatesFilter_Conjunction_OR = 2
};
bool CoordinatesFilter_Conjunction_IsValid(int value);
const CoordinatesFilter_Conjunction CoordinatesFilter_Conjunction_Conjunction_MIN = CoordinatesFilter_Conjunction_AND;
const CoordinatesFilter_Conjunction CoordinatesFilter_Conjunction_Conjunction_MAX = CoordinatesFilter_Conjunction_OR;
const int CoordinatesFilter_Conjunction_Conjunction_ARRAYSIZE = CoordinatesFilter_Conjunction_Conjunction_MAX + 1;

const ::google::protobuf::EnumDescriptor* CoordinatesFilter_Conjunction_descriptor();
inline const ::std::string& CoordinatesFilter_Conjunction_Name(CoordinatesFilter_Conjunction value) {
  return ::google::protobuf::internal::NameOfEnum(
    CoordinatesFilter_Conjunction_descriptor(), value);
}
inline bool CoordinatesFilter_Conjunction_Parse(
    const ::std::string& name, CoordinatesFilter_Conjunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoordinatesFilter_Conjunction>(
    CoordinatesFilter_Conjunction_descriptor(), name, value);
}
enum ManagerToCoreMessage_MTCMessageType {
  ManagerToCoreMessage_MTCMessageType_OPTIONS = 1,
  ManagerToCoreMessage_MTCMessageType_FILTERS = 2,
  ManagerToCoreMessage_MTCMessageType_CONTINUE = 3,
  ManagerToCoreMessage_MTCMessageType_ABORT = 4,
  ManagerToCoreMessage_MTCMessageType_HELLO = 5
};
bool ManagerToCoreMessage_MTCMessageType_IsValid(int value);
const ManagerToCoreMessage_MTCMessageType ManagerToCoreMessage_MTCMessageType_MTCMessageType_MIN = ManagerToCoreMessage_MTCMessageType_OPTIONS;
const ManagerToCoreMessage_MTCMessageType ManagerToCoreMessage_MTCMessageType_MTCMessageType_MAX = ManagerToCoreMessage_MTCMessageType_HELLO;
const int ManagerToCoreMessage_MTCMessageType_MTCMessageType_ARRAYSIZE = ManagerToCoreMessage_MTCMessageType_MTCMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ManagerToCoreMessage_MTCMessageType_descriptor();
inline const ::std::string& ManagerToCoreMessage_MTCMessageType_Name(ManagerToCoreMessage_MTCMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ManagerToCoreMessage_MTCMessageType_descriptor(), value);
}
inline bool ManagerToCoreMessage_MTCMessageType_Parse(
    const ::std::string& name, ManagerToCoreMessage_MTCMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ManagerToCoreMessage_MTCMessageType>(
    ManagerToCoreMessage_MTCMessageType_descriptor(), name, value);
}
enum ComparisonOperator {
  GREATER_OR_EQUAL = 1,
  GREATER = 2,
  EQUAL = 3,
  LESS_OR_EQUAL = 4,
  LESS = 5
};
bool ComparisonOperator_IsValid(int value);
const ComparisonOperator ComparisonOperator_MIN = GREATER_OR_EQUAL;
const ComparisonOperator ComparisonOperator_MAX = LESS;
const int ComparisonOperator_ARRAYSIZE = ComparisonOperator_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComparisonOperator_descriptor();
inline const ::std::string& ComparisonOperator_Name(ComparisonOperator value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComparisonOperator_descriptor(), value);
}
inline bool ComparisonOperator_Parse(
    const ::std::string& name, ComparisonOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComparisonOperator>(
    ComparisonOperator_descriptor(), name, value);
}
// ===================================================================

class ElementInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.ElementInfo) */ {
 public:
  ElementInfo();
  virtual ~ElementInfo();

  ElementInfo(const ElementInfo& from);

  inline ElementInfo& operator=(const ElementInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementInfo& default_instance();

  void Swap(ElementInfo* other);

  // implements Message ----------------------------------------------

  inline ElementInfo* New() const { return New(NULL); }

  ElementInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ElementInfo& from);
  void MergeFrom(const ElementInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 total = 1;
  bool has_total() const;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int32 total() const;
  void set_total(::google::protobuf::int32 value);

  // required int32 visible = 2;
  bool has_visible() const;
  void clear_visible();
  static const int kVisibleFieldNumber = 2;
  ::google::protobuf::int32 visible() const;
  void set_visible(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sm.ElementInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_visible();
  inline void clear_has_visible();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 visible_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static ElementInfo* default_instance_;
};
// -------------------------------------------------------------------

class ElementsCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.ElementsCount) */ {
 public:
  ElementsCount();
  virtual ~ElementsCount();

  ElementsCount(const ElementsCount& from);

  inline ElementsCount& operator=(const ElementsCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementsCount& default_instance();

  void Swap(ElementsCount* other);

  // implements Message ----------------------------------------------

  inline ElementsCount* New() const { return New(NULL); }

  ElementsCount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ElementsCount& from);
  void MergeFrom(const ElementsCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementsCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .sm.ElementInfo> elementInfos = 1;
  int elementinfos_size() const;
  void clear_elementinfos();
  static const int kElementInfosFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::sm::ElementInfo >&
      elementinfos() const;
  ::google::protobuf::Map< ::std::string, ::sm::ElementInfo >*
      mutable_elementinfos();

  // @@protoc_insertion_point(class_scope:sm.ElementsCount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::sm::ElementInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      ElementsCount_ElementInfosEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::sm::ElementInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > elementinfos_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static ElementsCount* default_instance_;
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.BoundingBox) */ {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox& default_instance();

  void Swap(BoundingBox* other);

  // implements Message ----------------------------------------------

  inline BoundingBox* New() const { return New(NULL); }

  BoundingBox* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoundingBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double fromX = 1;
  bool has_fromx() const;
  void clear_fromx();
  static const int kFromXFieldNumber = 1;
  double fromx() const;
  void set_fromx(double value);

  // required double toX = 2;
  bool has_tox() const;
  void clear_tox();
  static const int kToXFieldNumber = 2;
  double tox() const;
  void set_tox(double value);

  // required double fromY = 3;
  bool has_fromy() const;
  void clear_fromy();
  static const int kFromYFieldNumber = 3;
  double fromy() const;
  void set_fromy(double value);

  // required double toY = 4;
  bool has_toy() const;
  void clear_toy();
  static const int kToYFieldNumber = 4;
  double toy() const;
  void set_toy(double value);

  // required double fromZ = 5;
  bool has_fromz() const;
  void clear_fromz();
  static const int kFromZFieldNumber = 5;
  double fromz() const;
  void set_fromz(double value);

  // required double toZ = 6;
  bool has_toz() const;
  void clear_toz();
  static const int kToZFieldNumber = 6;
  double toz() const;
  void set_toz(double value);

  // @@protoc_insertion_point(class_scope:sm.BoundingBox)
 private:
  inline void set_has_fromx();
  inline void clear_has_fromx();
  inline void set_has_tox();
  inline void clear_has_tox();
  inline void set_has_fromy();
  inline void clear_has_fromy();
  inline void set_has_toy();
  inline void clear_has_toy();
  inline void set_has_fromz();
  inline void clear_has_fromz();
  inline void set_has_toz();
  inline void clear_has_toz();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double fromx_;
  double tox_;
  double fromy_;
  double toy_;
  double fromz_;
  double toz_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class GroupsInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.GroupsInfo) */ {
 public:
  GroupsInfo();
  virtual ~GroupsInfo();

  GroupsInfo(const GroupsInfo& from);

  inline GroupsInfo& operator=(const GroupsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupsInfo& default_instance();

  void Swap(GroupsInfo* other);

  // implements Message ----------------------------------------------

  inline GroupsInfo* New() const { return New(NULL); }

  GroupsInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupsInfo& from);
  void MergeFrom(const GroupsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupsInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string allGroups = 1;
  int allgroups_size() const;
  void clear_allgroups();
  static const int kAllGroupsFieldNumber = 1;
  const ::std::string& allgroups(int index) const;
  ::std::string* mutable_allgroups(int index);
  void set_allgroups(int index, const ::std::string& value);
  void set_allgroups(int index, const char* value);
  void set_allgroups(int index, const char* value, size_t size);
  ::std::string* add_allgroups();
  void add_allgroups(const ::std::string& value);
  void add_allgroups(const char* value);
  void add_allgroups(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& allgroups() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allgroups();

  // @@protoc_insertion_point(class_scope:sm.GroupsInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allgroups_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static GroupsInfo* default_instance_;
};
// -------------------------------------------------------------------

class StatisticsInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.StatisticsInfo) */ {
 public:
  StatisticsInfo();
  virtual ~StatisticsInfo();

  StatisticsInfo(const StatisticsInfo& from);

  inline StatisticsInfo& operator=(const StatisticsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatisticsInfo& default_instance();

  void Swap(StatisticsInfo* other);

  // implements Message ----------------------------------------------

  inline StatisticsInfo* New() const { return New(NULL); }

  StatisticsInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatisticsInfo& from);
  void MergeFrom(const StatisticsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatisticsInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sm.ElementsCount elementsCount = 1;
  bool has_elementscount() const;
  void clear_elementscount();
  static const int kElementsCountFieldNumber = 1;
  const ::sm::ElementsCount& elementscount() const;
  ::sm::ElementsCount* mutable_elementscount();
  ::sm::ElementsCount* release_elementscount();
  void set_allocated_elementscount(::sm::ElementsCount* elementscount);

  // required .sm.BoundingBox boundingBox = 2;
  bool has_boundingbox() const;
  void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 2;
  const ::sm::BoundingBox& boundingbox() const;
  ::sm::BoundingBox* mutable_boundingbox();
  ::sm::BoundingBox* release_boundingbox();
  void set_allocated_boundingbox(::sm::BoundingBox* boundingbox);

  // required .sm.GroupsInfo groupsInfo = 3;
  bool has_groupsinfo() const;
  void clear_groupsinfo();
  static const int kGroupsInfoFieldNumber = 3;
  const ::sm::GroupsInfo& groupsinfo() const;
  ::sm::GroupsInfo* mutable_groupsinfo();
  ::sm::GroupsInfo* release_groupsinfo();
  void set_allocated_groupsinfo(::sm::GroupsInfo* groupsinfo);

  // @@protoc_insertion_point(class_scope:sm.StatisticsInfo)
 private:
  inline void set_has_elementscount();
  inline void clear_has_elementscount();
  inline void set_has_boundingbox();
  inline void clear_has_boundingbox();
  inline void set_has_groupsinfo();
  inline void clear_has_groupsinfo();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::sm::ElementsCount* elementscount_;
  ::sm::BoundingBox* boundingbox_;
  ::sm::GroupsInfo* groupsinfo_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static StatisticsInfo* default_instance_;
};
// -------------------------------------------------------------------

class CoreToManagerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.CoreToManagerMessage) */ {
 public:
  CoreToManagerMessage();
  virtual ~CoreToManagerMessage();

  CoreToManagerMessage(const CoreToManagerMessage& from);

  inline CoreToManagerMessage& operator=(const CoreToManagerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoreToManagerMessage& default_instance();

  void Swap(CoreToManagerMessage* other);

  // implements Message ----------------------------------------------

  inline CoreToManagerMessage* New() const { return New(NULL); }

  CoreToManagerMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoreToManagerMessage& from);
  void MergeFrom(const CoreToManagerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CoreToManagerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CoreToManagerMessage_CTMMessageType CTMMessageType;
  static const CTMMessageType STATISTICS =
    CoreToManagerMessage_CTMMessageType_STATISTICS;
  static const CTMMessageType BREAKPOINT =
    CoreToManagerMessage_CTMMessageType_BREAKPOINT;
  static inline bool CTMMessageType_IsValid(int value) {
    return CoreToManagerMessage_CTMMessageType_IsValid(value);
  }
  static const CTMMessageType CTMMessageType_MIN =
    CoreToManagerMessage_CTMMessageType_CTMMessageType_MIN;
  static const CTMMessageType CTMMessageType_MAX =
    CoreToManagerMessage_CTMMessageType_CTMMessageType_MAX;
  static const int CTMMessageType_ARRAYSIZE =
    CoreToManagerMessage_CTMMessageType_CTMMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CTMMessageType_descriptor() {
    return CoreToManagerMessage_CTMMessageType_descriptor();
  }
  static inline const ::std::string& CTMMessageType_Name(CTMMessageType value) {
    return CoreToManagerMessage_CTMMessageType_Name(value);
  }
  static inline bool CTMMessageType_Parse(const ::std::string& name,
      CTMMessageType* value) {
    return CoreToManagerMessage_CTMMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .sm.CoreToManagerMessage.CTMMessageType messageType = 1;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  ::sm::CoreToManagerMessage_CTMMessageType messagetype() const;
  void set_messagetype(::sm::CoreToManagerMessage_CTMMessageType value);

  // optional .sm.StatisticsInfo statisticsInfo = 2;
  bool has_statisticsinfo() const;
  void clear_statisticsinfo();
  static const int kStatisticsInfoFieldNumber = 2;
  const ::sm::StatisticsInfo& statisticsinfo() const;
  ::sm::StatisticsInfo* mutable_statisticsinfo();
  ::sm::StatisticsInfo* release_statisticsinfo();
  void set_allocated_statisticsinfo(::sm::StatisticsInfo* statisticsinfo);

  // @@protoc_insertion_point(class_scope:sm.CoreToManagerMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_statisticsinfo();
  inline void clear_has_statisticsinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::sm::StatisticsInfo* statisticsinfo_;
  int messagetype_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static CoreToManagerMessage* default_instance_;
};
// -------------------------------------------------------------------

class OptionsInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.OptionsInfo) */ {
 public:
  OptionsInfo();
  virtual ~OptionsInfo();

  OptionsInfo(const OptionsInfo& from);

  inline OptionsInfo& operator=(const OptionsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionsInfo& default_instance();

  void Swap(OptionsInfo* other);

  // implements Message ----------------------------------------------

  inline OptionsInfo* New() const { return New(NULL); }

  OptionsInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptionsInfo& from);
  void MergeFrom(const OptionsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OptionsInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool transparentStructures = 1;
  bool has_transparentstructures() const;
  void clear_transparentstructures();
  static const int kTransparentStructuresFieldNumber = 1;
  bool transparentstructures() const;
  void set_transparentstructures(bool value);

  // required bool dynamicRendering = 2;
  bool has_dynamicrendering() const;
  void clear_dynamicrendering();
  static const int kDynamicRenderingFieldNumber = 2;
  bool dynamicrendering() const;
  void set_dynamicrendering(bool value);

  // required bool showLabels = 3;
  bool has_showlabels() const;
  void clear_showlabels();
  static const int kShowLabelsFieldNumber = 3;
  bool showlabels() const;
  void set_showlabels(bool value);

  // required double mouseSensitivity = 4;
  bool has_mousesensitivity() const;
  void clear_mousesensitivity();
  static const int kMouseSensitivityFieldNumber = 4;
  double mousesensitivity() const;
  void set_mousesensitivity(double value);

  // @@protoc_insertion_point(class_scope:sm.OptionsInfo)
 private:
  inline void set_has_transparentstructures();
  inline void clear_has_transparentstructures();
  inline void set_has_dynamicrendering();
  inline void clear_has_dynamicrendering();
  inline void set_has_showlabels();
  inline void clear_has_showlabels();
  inline void set_has_mousesensitivity();
  inline void clear_has_mousesensitivity();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double mousesensitivity_;
  bool transparentstructures_;
  bool dynamicrendering_;
  bool showlabels_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static OptionsInfo* default_instance_;
};
// -------------------------------------------------------------------

class TypesFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.TypesFilter) */ {
 public:
  TypesFilter();
  virtual ~TypesFilter();

  TypesFilter(const TypesFilter& from);

  inline TypesFilter& operator=(const TypesFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypesFilter& default_instance();

  void Swap(TypesFilter* other);

  // implements Message ----------------------------------------------

  inline TypesFilter* New() const { return New(NULL); }

  TypesFilter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypesFilter& from);
  void MergeFrom(const TypesFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TypesFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bool> selectedTypes = 1;
  int selectedtypes_size() const;
  void clear_selectedtypes();
  static const int kSelectedTypesFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, bool >&
      selectedtypes() const;
  ::google::protobuf::Map< ::std::string, bool >*
      mutable_selectedtypes();

  // @@protoc_insertion_point(class_scope:sm.TypesFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 >
      TypesFilter_SelectedTypesEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 > selectedtypes_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static TypesFilter* default_instance_;
};
// -------------------------------------------------------------------

class GroupsFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.GroupsFilter) */ {
 public:
  GroupsFilter();
  virtual ~GroupsFilter();

  GroupsFilter(const GroupsFilter& from);

  inline GroupsFilter& operator=(const GroupsFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupsFilter& default_instance();

  void Swap(GroupsFilter* other);

  // implements Message ----------------------------------------------

  inline GroupsFilter* New() const { return New(NULL); }

  GroupsFilter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupsFilter& from);
  void MergeFrom(const GroupsFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupsFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bool> selectedGroups = 1;
  int selectedgroups_size() const;
  void clear_selectedgroups();
  static const int kSelectedGroupsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, bool >&
      selectedgroups() const;
  ::google::protobuf::Map< ::std::string, bool >*
      mutable_selectedgroups();

  // @@protoc_insertion_point(class_scope:sm.GroupsFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 >
      GroupsFilter_SelectedGroupsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 > selectedgroups_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static GroupsFilter* default_instance_;
};
// -------------------------------------------------------------------

class QualityCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.QualityCondition) */ {
 public:
  QualityCondition();
  virtual ~QualityCondition();

  QualityCondition(const QualityCondition& from);

  inline QualityCondition& operator=(const QualityCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QualityCondition& default_instance();

  void Swap(QualityCondition* other);

  // implements Message ----------------------------------------------

  inline QualityCondition* New() const { return New(NULL); }

  QualityCondition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QualityCondition& from);
  void MergeFrom(const QualityCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QualityCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double leftValue = 1;
  bool has_leftvalue() const;
  void clear_leftvalue();
  static const int kLeftValueFieldNumber = 1;
  double leftvalue() const;
  void set_leftvalue(double value);

  // optional .sm.ComparisonOperator leftOperator = 2;
  bool has_leftoperator() const;
  void clear_leftoperator();
  static const int kLeftOperatorFieldNumber = 2;
  ::sm::ComparisonOperator leftoperator() const;
  void set_leftoperator(::sm::ComparisonOperator value);

  // optional .sm.ComparisonOperator rightOperator = 3;
  bool has_rightoperator() const;
  void clear_rightoperator();
  static const int kRightOperatorFieldNumber = 3;
  ::sm::ComparisonOperator rightoperator() const;
  void set_rightoperator(::sm::ComparisonOperator value);

  // optional double rightValue = 4;
  bool has_rightvalue() const;
  void clear_rightvalue();
  static const int kRightValueFieldNumber = 4;
  double rightvalue() const;
  void set_rightvalue(double value);

  // @@protoc_insertion_point(class_scope:sm.QualityCondition)
 private:
  inline void set_has_leftvalue();
  inline void clear_has_leftvalue();
  inline void set_has_leftoperator();
  inline void clear_has_leftoperator();
  inline void set_has_rightoperator();
  inline void clear_has_rightoperator();
  inline void set_has_rightvalue();
  inline void clear_has_rightvalue();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double leftvalue_;
  int leftoperator_;
  int rightoperator_;
  double rightvalue_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static QualityCondition* default_instance_;
};
// -------------------------------------------------------------------

class QualityFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.QualityFilter) */ {
 public:
  QualityFilter();
  virtual ~QualityFilter();

  QualityFilter(const QualityFilter& from);

  inline QualityFilter& operator=(const QualityFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QualityFilter& default_instance();

  void Swap(QualityFilter* other);

  // implements Message ----------------------------------------------

  inline QualityFilter* New() const { return New(NULL); }

  QualityFilter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QualityFilter& from);
  void MergeFrom(const QualityFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QualityFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sm.QualityCondition qualityCondition = 1;
  int qualitycondition_size() const;
  void clear_qualitycondition();
  static const int kQualityConditionFieldNumber = 1;
  const ::sm::QualityCondition& qualitycondition(int index) const;
  ::sm::QualityCondition* mutable_qualitycondition(int index);
  ::sm::QualityCondition* add_qualitycondition();
  ::google::protobuf::RepeatedPtrField< ::sm::QualityCondition >*
      mutable_qualitycondition();
  const ::google::protobuf::RepeatedPtrField< ::sm::QualityCondition >&
      qualitycondition() const;

  // @@protoc_insertion_point(class_scope:sm.QualityFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sm::QualityCondition > qualitycondition_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static QualityFilter* default_instance_;
};
// -------------------------------------------------------------------

class CoordinatesCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.CoordinatesCondition) */ {
 public:
  CoordinatesCondition();
  virtual ~CoordinatesCondition();

  CoordinatesCondition(const CoordinatesCondition& from);

  inline CoordinatesCondition& operator=(const CoordinatesCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordinatesCondition& default_instance();

  void Swap(CoordinatesCondition* other);

  // implements Message ----------------------------------------------

  inline CoordinatesCondition* New() const { return New(NULL); }

  CoordinatesCondition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoordinatesCondition& from);
  void MergeFrom(const CoordinatesCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CoordinatesCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double xValue = 1;
  bool has_xvalue() const;
  void clear_xvalue();
  static const int kXValueFieldNumber = 1;
  double xvalue() const;
  void set_xvalue(double value);

  // required double yValue = 2;
  bool has_yvalue() const;
  void clear_yvalue();
  static const int kYValueFieldNumber = 2;
  double yvalue() const;
  void set_yvalue(double value);

  // required double zValue = 3;
  bool has_zvalue() const;
  void clear_zvalue();
  static const int kZValueFieldNumber = 3;
  double zvalue() const;
  void set_zvalue(double value);

  // required .sm.ComparisonOperator coordinatesOperator = 4;
  bool has_coordinatesoperator() const;
  void clear_coordinatesoperator();
  static const int kCoordinatesOperatorFieldNumber = 4;
  ::sm::ComparisonOperator coordinatesoperator() const;
  void set_coordinatesoperator(::sm::ComparisonOperator value);

  // required double constant = 5;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 5;
  double constant() const;
  void set_constant(double value);

  // @@protoc_insertion_point(class_scope:sm.CoordinatesCondition)
 private:
  inline void set_has_xvalue();
  inline void clear_has_xvalue();
  inline void set_has_yvalue();
  inline void clear_has_yvalue();
  inline void set_has_zvalue();
  inline void clear_has_zvalue();
  inline void set_has_coordinatesoperator();
  inline void clear_has_coordinatesoperator();
  inline void set_has_constant();
  inline void clear_has_constant();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double xvalue_;
  double yvalue_;
  double zvalue_;
  double constant_;
  int coordinatesoperator_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static CoordinatesCondition* default_instance_;
};
// -------------------------------------------------------------------

class CoordinatesFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.CoordinatesFilter) */ {
 public:
  CoordinatesFilter();
  virtual ~CoordinatesFilter();

  CoordinatesFilter(const CoordinatesFilter& from);

  inline CoordinatesFilter& operator=(const CoordinatesFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordinatesFilter& default_instance();

  void Swap(CoordinatesFilter* other);

  // implements Message ----------------------------------------------

  inline CoordinatesFilter* New() const { return New(NULL); }

  CoordinatesFilter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoordinatesFilter& from);
  void MergeFrom(const CoordinatesFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CoordinatesFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CoordinatesFilter_Conjunction Conjunction;
  static const Conjunction AND =
    CoordinatesFilter_Conjunction_AND;
  static const Conjunction OR =
    CoordinatesFilter_Conjunction_OR;
  static inline bool Conjunction_IsValid(int value) {
    return CoordinatesFilter_Conjunction_IsValid(value);
  }
  static const Conjunction Conjunction_MIN =
    CoordinatesFilter_Conjunction_Conjunction_MIN;
  static const Conjunction Conjunction_MAX =
    CoordinatesFilter_Conjunction_Conjunction_MAX;
  static const int Conjunction_ARRAYSIZE =
    CoordinatesFilter_Conjunction_Conjunction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Conjunction_descriptor() {
    return CoordinatesFilter_Conjunction_descriptor();
  }
  static inline const ::std::string& Conjunction_Name(Conjunction value) {
    return CoordinatesFilter_Conjunction_Name(value);
  }
  static inline bool Conjunction_Parse(const ::std::string& name,
      Conjunction* value) {
    return CoordinatesFilter_Conjunction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .sm.CoordinatesCondition coordinatesCondition = 1;
  int coordinatescondition_size() const;
  void clear_coordinatescondition();
  static const int kCoordinatesConditionFieldNumber = 1;
  const ::sm::CoordinatesCondition& coordinatescondition(int index) const;
  ::sm::CoordinatesCondition* mutable_coordinatescondition(int index);
  ::sm::CoordinatesCondition* add_coordinatescondition();
  ::google::protobuf::RepeatedPtrField< ::sm::CoordinatesCondition >*
      mutable_coordinatescondition();
  const ::google::protobuf::RepeatedPtrField< ::sm::CoordinatesCondition >&
      coordinatescondition() const;

  // optional .sm.CoordinatesFilter.Conjunction conjunction = 2;
  bool has_conjunction() const;
  void clear_conjunction();
  static const int kConjunctionFieldNumber = 2;
  ::sm::CoordinatesFilter_Conjunction conjunction() const;
  void set_conjunction(::sm::CoordinatesFilter_Conjunction value);

  // @@protoc_insertion_point(class_scope:sm.CoordinatesFilter)
 private:
  inline void set_has_conjunction();
  inline void clear_has_conjunction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sm::CoordinatesCondition > coordinatescondition_;
  int conjunction_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static CoordinatesFilter* default_instance_;
};
// -------------------------------------------------------------------

class ManagerToCoreMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sm.ManagerToCoreMessage) */ {
 public:
  ManagerToCoreMessage();
  virtual ~ManagerToCoreMessage();

  ManagerToCoreMessage(const ManagerToCoreMessage& from);

  inline ManagerToCoreMessage& operator=(const ManagerToCoreMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManagerToCoreMessage& default_instance();

  void Swap(ManagerToCoreMessage* other);

  // implements Message ----------------------------------------------

  inline ManagerToCoreMessage* New() const { return New(NULL); }

  ManagerToCoreMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManagerToCoreMessage& from);
  void MergeFrom(const ManagerToCoreMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ManagerToCoreMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ManagerToCoreMessage_MTCMessageType MTCMessageType;
  static const MTCMessageType OPTIONS =
    ManagerToCoreMessage_MTCMessageType_OPTIONS;
  static const MTCMessageType FILTERS =
    ManagerToCoreMessage_MTCMessageType_FILTERS;
  static const MTCMessageType CONTINUE =
    ManagerToCoreMessage_MTCMessageType_CONTINUE;
  static const MTCMessageType ABORT =
    ManagerToCoreMessage_MTCMessageType_ABORT;
  static const MTCMessageType HELLO =
    ManagerToCoreMessage_MTCMessageType_HELLO;
  static inline bool MTCMessageType_IsValid(int value) {
    return ManagerToCoreMessage_MTCMessageType_IsValid(value);
  }
  static const MTCMessageType MTCMessageType_MIN =
    ManagerToCoreMessage_MTCMessageType_MTCMessageType_MIN;
  static const MTCMessageType MTCMessageType_MAX =
    ManagerToCoreMessage_MTCMessageType_MTCMessageType_MAX;
  static const int MTCMessageType_ARRAYSIZE =
    ManagerToCoreMessage_MTCMessageType_MTCMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MTCMessageType_descriptor() {
    return ManagerToCoreMessage_MTCMessageType_descriptor();
  }
  static inline const ::std::string& MTCMessageType_Name(MTCMessageType value) {
    return ManagerToCoreMessage_MTCMessageType_Name(value);
  }
  static inline bool MTCMessageType_Parse(const ::std::string& name,
      MTCMessageType* value) {
    return ManagerToCoreMessage_MTCMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .sm.ManagerToCoreMessage.MTCMessageType messageType = 1;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  ::sm::ManagerToCoreMessage_MTCMessageType messagetype() const;
  void set_messagetype(::sm::ManagerToCoreMessage_MTCMessageType value);

  // optional .sm.OptionsInfo optionsInfo = 2;
  bool has_optionsinfo() const;
  void clear_optionsinfo();
  static const int kOptionsInfoFieldNumber = 2;
  const ::sm::OptionsInfo& optionsinfo() const;
  ::sm::OptionsInfo* mutable_optionsinfo();
  ::sm::OptionsInfo* release_optionsinfo();
  void set_allocated_optionsinfo(::sm::OptionsInfo* optionsinfo);

  // optional .sm.GroupsFilter groupsFilter = 3;
  bool has_groupsfilter() const;
  void clear_groupsfilter();
  static const int kGroupsFilterFieldNumber = 3;
  const ::sm::GroupsFilter& groupsfilter() const;
  ::sm::GroupsFilter* mutable_groupsfilter();
  ::sm::GroupsFilter* release_groupsfilter();
  void set_allocated_groupsfilter(::sm::GroupsFilter* groupsfilter);

  // optional .sm.TypesFilter typesFilter = 4;
  bool has_typesfilter() const;
  void clear_typesfilter();
  static const int kTypesFilterFieldNumber = 4;
  const ::sm::TypesFilter& typesfilter() const;
  ::sm::TypesFilter* mutable_typesfilter();
  ::sm::TypesFilter* release_typesfilter();
  void set_allocated_typesfilter(::sm::TypesFilter* typesfilter);

  // optional .sm.QualityFilter qualityFilter = 5;
  bool has_qualityfilter() const;
  void clear_qualityfilter();
  static const int kQualityFilterFieldNumber = 5;
  const ::sm::QualityFilter& qualityfilter() const;
  ::sm::QualityFilter* mutable_qualityfilter();
  ::sm::QualityFilter* release_qualityfilter();
  void set_allocated_qualityfilter(::sm::QualityFilter* qualityfilter);

  // optional .sm.CoordinatesFilter coordinatesFilter = 6;
  bool has_coordinatesfilter() const;
  void clear_coordinatesfilter();
  static const int kCoordinatesFilterFieldNumber = 6;
  const ::sm::CoordinatesFilter& coordinatesfilter() const;
  ::sm::CoordinatesFilter* mutable_coordinatesfilter();
  ::sm::CoordinatesFilter* release_coordinatesfilter();
  void set_allocated_coordinatesfilter(::sm::CoordinatesFilter* coordinatesfilter);

  // @@protoc_insertion_point(class_scope:sm.ManagerToCoreMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_optionsinfo();
  inline void clear_has_optionsinfo();
  inline void set_has_groupsfilter();
  inline void clear_has_groupsfilter();
  inline void set_has_typesfilter();
  inline void clear_has_typesfilter();
  inline void set_has_qualityfilter();
  inline void clear_has_qualityfilter();
  inline void set_has_coordinatesfilter();
  inline void clear_has_coordinatesfilter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::sm::OptionsInfo* optionsinfo_;
  ::sm::GroupsFilter* groupsfilter_;
  ::sm::TypesFilter* typesfilter_;
  ::sm::QualityFilter* qualityfilter_;
  ::sm::CoordinatesFilter* coordinatesfilter_;
  int messagetype_;
  friend void  protobuf_AddDesc_communication_2eproto();
  friend void protobuf_AssignDesc_communication_2eproto();
  friend void protobuf_ShutdownFile_communication_2eproto();

  void InitAsDefaultInstance();
  static ManagerToCoreMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ElementInfo

// required int32 total = 1;
inline bool ElementInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElementInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElementInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElementInfo::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 ElementInfo::total() const {
  // @@protoc_insertion_point(field_get:sm.ElementInfo.total)
  return total_;
}
inline void ElementInfo::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
  // @@protoc_insertion_point(field_set:sm.ElementInfo.total)
}

// required int32 visible = 2;
inline bool ElementInfo::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElementInfo::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElementInfo::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElementInfo::clear_visible() {
  visible_ = 0;
  clear_has_visible();
}
inline ::google::protobuf::int32 ElementInfo::visible() const {
  // @@protoc_insertion_point(field_get:sm.ElementInfo.visible)
  return visible_;
}
inline void ElementInfo::set_visible(::google::protobuf::int32 value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:sm.ElementInfo.visible)
}

// -------------------------------------------------------------------

// ElementsCount

// map<string, .sm.ElementInfo> elementInfos = 1;
inline int ElementsCount::elementinfos_size() const {
  return elementinfos_.size();
}
inline void ElementsCount::clear_elementinfos() {
  elementinfos_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::sm::ElementInfo >&
ElementsCount::elementinfos() const {
  // @@protoc_insertion_point(field_map:sm.ElementsCount.elementInfos)
  return elementinfos_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::sm::ElementInfo >*
ElementsCount::mutable_elementinfos() {
  // @@protoc_insertion_point(field_mutable_map:sm.ElementsCount.elementInfos)
  return elementinfos_.MutableMap();
}

// -------------------------------------------------------------------

// BoundingBox

// required double fromX = 1;
inline bool BoundingBox::has_fromx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundingBox::set_has_fromx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundingBox::clear_has_fromx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundingBox::clear_fromx() {
  fromx_ = 0;
  clear_has_fromx();
}
inline double BoundingBox::fromx() const {
  // @@protoc_insertion_point(field_get:sm.BoundingBox.fromX)
  return fromx_;
}
inline void BoundingBox::set_fromx(double value) {
  set_has_fromx();
  fromx_ = value;
  // @@protoc_insertion_point(field_set:sm.BoundingBox.fromX)
}

// required double toX = 2;
inline bool BoundingBox::has_tox() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundingBox::set_has_tox() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundingBox::clear_has_tox() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundingBox::clear_tox() {
  tox_ = 0;
  clear_has_tox();
}
inline double BoundingBox::tox() const {
  // @@protoc_insertion_point(field_get:sm.BoundingBox.toX)
  return tox_;
}
inline void BoundingBox::set_tox(double value) {
  set_has_tox();
  tox_ = value;
  // @@protoc_insertion_point(field_set:sm.BoundingBox.toX)
}

// required double fromY = 3;
inline bool BoundingBox::has_fromy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundingBox::set_has_fromy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoundingBox::clear_has_fromy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoundingBox::clear_fromy() {
  fromy_ = 0;
  clear_has_fromy();
}
inline double BoundingBox::fromy() const {
  // @@protoc_insertion_point(field_get:sm.BoundingBox.fromY)
  return fromy_;
}
inline void BoundingBox::set_fromy(double value) {
  set_has_fromy();
  fromy_ = value;
  // @@protoc_insertion_point(field_set:sm.BoundingBox.fromY)
}

// required double toY = 4;
inline bool BoundingBox::has_toy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoundingBox::set_has_toy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoundingBox::clear_has_toy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoundingBox::clear_toy() {
  toy_ = 0;
  clear_has_toy();
}
inline double BoundingBox::toy() const {
  // @@protoc_insertion_point(field_get:sm.BoundingBox.toY)
  return toy_;
}
inline void BoundingBox::set_toy(double value) {
  set_has_toy();
  toy_ = value;
  // @@protoc_insertion_point(field_set:sm.BoundingBox.toY)
}

// required double fromZ = 5;
inline bool BoundingBox::has_fromz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BoundingBox::set_has_fromz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BoundingBox::clear_has_fromz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BoundingBox::clear_fromz() {
  fromz_ = 0;
  clear_has_fromz();
}
inline double BoundingBox::fromz() const {
  // @@protoc_insertion_point(field_get:sm.BoundingBox.fromZ)
  return fromz_;
}
inline void BoundingBox::set_fromz(double value) {
  set_has_fromz();
  fromz_ = value;
  // @@protoc_insertion_point(field_set:sm.BoundingBox.fromZ)
}

// required double toZ = 6;
inline bool BoundingBox::has_toz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BoundingBox::set_has_toz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BoundingBox::clear_has_toz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BoundingBox::clear_toz() {
  toz_ = 0;
  clear_has_toz();
}
inline double BoundingBox::toz() const {
  // @@protoc_insertion_point(field_get:sm.BoundingBox.toZ)
  return toz_;
}
inline void BoundingBox::set_toz(double value) {
  set_has_toz();
  toz_ = value;
  // @@protoc_insertion_point(field_set:sm.BoundingBox.toZ)
}

// -------------------------------------------------------------------

// GroupsInfo

// repeated string allGroups = 1;
inline int GroupsInfo::allgroups_size() const {
  return allgroups_.size();
}
inline void GroupsInfo::clear_allgroups() {
  allgroups_.Clear();
}
inline const ::std::string& GroupsInfo::allgroups(int index) const {
  // @@protoc_insertion_point(field_get:sm.GroupsInfo.allGroups)
  return allgroups_.Get(index);
}
inline ::std::string* GroupsInfo::mutable_allgroups(int index) {
  // @@protoc_insertion_point(field_mutable:sm.GroupsInfo.allGroups)
  return allgroups_.Mutable(index);
}
inline void GroupsInfo::set_allgroups(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:sm.GroupsInfo.allGroups)
  allgroups_.Mutable(index)->assign(value);
}
inline void GroupsInfo::set_allgroups(int index, const char* value) {
  allgroups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sm.GroupsInfo.allGroups)
}
inline void GroupsInfo::set_allgroups(int index, const char* value, size_t size) {
  allgroups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sm.GroupsInfo.allGroups)
}
inline ::std::string* GroupsInfo::add_allgroups() {
  // @@protoc_insertion_point(field_add_mutable:sm.GroupsInfo.allGroups)
  return allgroups_.Add();
}
inline void GroupsInfo::add_allgroups(const ::std::string& value) {
  allgroups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sm.GroupsInfo.allGroups)
}
inline void GroupsInfo::add_allgroups(const char* value) {
  allgroups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sm.GroupsInfo.allGroups)
}
inline void GroupsInfo::add_allgroups(const char* value, size_t size) {
  allgroups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sm.GroupsInfo.allGroups)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupsInfo::allgroups() const {
  // @@protoc_insertion_point(field_list:sm.GroupsInfo.allGroups)
  return allgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupsInfo::mutable_allgroups() {
  // @@protoc_insertion_point(field_mutable_list:sm.GroupsInfo.allGroups)
  return &allgroups_;
}

// -------------------------------------------------------------------

// StatisticsInfo

// required .sm.ElementsCount elementsCount = 1;
inline bool StatisticsInfo::has_elementscount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatisticsInfo::set_has_elementscount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatisticsInfo::clear_has_elementscount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatisticsInfo::clear_elementscount() {
  if (elementscount_ != NULL) elementscount_->::sm::ElementsCount::Clear();
  clear_has_elementscount();
}
inline const ::sm::ElementsCount& StatisticsInfo::elementscount() const {
  // @@protoc_insertion_point(field_get:sm.StatisticsInfo.elementsCount)
  return elementscount_ != NULL ? *elementscount_ : *default_instance_->elementscount_;
}
inline ::sm::ElementsCount* StatisticsInfo::mutable_elementscount() {
  set_has_elementscount();
  if (elementscount_ == NULL) {
    elementscount_ = new ::sm::ElementsCount;
  }
  // @@protoc_insertion_point(field_mutable:sm.StatisticsInfo.elementsCount)
  return elementscount_;
}
inline ::sm::ElementsCount* StatisticsInfo::release_elementscount() {
  // @@protoc_insertion_point(field_release:sm.StatisticsInfo.elementsCount)
  clear_has_elementscount();
  ::sm::ElementsCount* temp = elementscount_;
  elementscount_ = NULL;
  return temp;
}
inline void StatisticsInfo::set_allocated_elementscount(::sm::ElementsCount* elementscount) {
  delete elementscount_;
  elementscount_ = elementscount;
  if (elementscount) {
    set_has_elementscount();
  } else {
    clear_has_elementscount();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.StatisticsInfo.elementsCount)
}

// required .sm.BoundingBox boundingBox = 2;
inline bool StatisticsInfo::has_boundingbox() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatisticsInfo::set_has_boundingbox() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatisticsInfo::clear_has_boundingbox() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatisticsInfo::clear_boundingbox() {
  if (boundingbox_ != NULL) boundingbox_->::sm::BoundingBox::Clear();
  clear_has_boundingbox();
}
inline const ::sm::BoundingBox& StatisticsInfo::boundingbox() const {
  // @@protoc_insertion_point(field_get:sm.StatisticsInfo.boundingBox)
  return boundingbox_ != NULL ? *boundingbox_ : *default_instance_->boundingbox_;
}
inline ::sm::BoundingBox* StatisticsInfo::mutable_boundingbox() {
  set_has_boundingbox();
  if (boundingbox_ == NULL) {
    boundingbox_ = new ::sm::BoundingBox;
  }
  // @@protoc_insertion_point(field_mutable:sm.StatisticsInfo.boundingBox)
  return boundingbox_;
}
inline ::sm::BoundingBox* StatisticsInfo::release_boundingbox() {
  // @@protoc_insertion_point(field_release:sm.StatisticsInfo.boundingBox)
  clear_has_boundingbox();
  ::sm::BoundingBox* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}
inline void StatisticsInfo::set_allocated_boundingbox(::sm::BoundingBox* boundingbox) {
  delete boundingbox_;
  boundingbox_ = boundingbox;
  if (boundingbox) {
    set_has_boundingbox();
  } else {
    clear_has_boundingbox();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.StatisticsInfo.boundingBox)
}

// required .sm.GroupsInfo groupsInfo = 3;
inline bool StatisticsInfo::has_groupsinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatisticsInfo::set_has_groupsinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatisticsInfo::clear_has_groupsinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatisticsInfo::clear_groupsinfo() {
  if (groupsinfo_ != NULL) groupsinfo_->::sm::GroupsInfo::Clear();
  clear_has_groupsinfo();
}
inline const ::sm::GroupsInfo& StatisticsInfo::groupsinfo() const {
  // @@protoc_insertion_point(field_get:sm.StatisticsInfo.groupsInfo)
  return groupsinfo_ != NULL ? *groupsinfo_ : *default_instance_->groupsinfo_;
}
inline ::sm::GroupsInfo* StatisticsInfo::mutable_groupsinfo() {
  set_has_groupsinfo();
  if (groupsinfo_ == NULL) {
    groupsinfo_ = new ::sm::GroupsInfo;
  }
  // @@protoc_insertion_point(field_mutable:sm.StatisticsInfo.groupsInfo)
  return groupsinfo_;
}
inline ::sm::GroupsInfo* StatisticsInfo::release_groupsinfo() {
  // @@protoc_insertion_point(field_release:sm.StatisticsInfo.groupsInfo)
  clear_has_groupsinfo();
  ::sm::GroupsInfo* temp = groupsinfo_;
  groupsinfo_ = NULL;
  return temp;
}
inline void StatisticsInfo::set_allocated_groupsinfo(::sm::GroupsInfo* groupsinfo) {
  delete groupsinfo_;
  groupsinfo_ = groupsinfo;
  if (groupsinfo) {
    set_has_groupsinfo();
  } else {
    clear_has_groupsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.StatisticsInfo.groupsInfo)
}

// -------------------------------------------------------------------

// CoreToManagerMessage

// required .sm.CoreToManagerMessage.CTMMessageType messageType = 1;
inline bool CoreToManagerMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoreToManagerMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoreToManagerMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoreToManagerMessage::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::sm::CoreToManagerMessage_CTMMessageType CoreToManagerMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:sm.CoreToManagerMessage.messageType)
  return static_cast< ::sm::CoreToManagerMessage_CTMMessageType >(messagetype_);
}
inline void CoreToManagerMessage::set_messagetype(::sm::CoreToManagerMessage_CTMMessageType value) {
  assert(::sm::CoreToManagerMessage_CTMMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:sm.CoreToManagerMessage.messageType)
}

// optional .sm.StatisticsInfo statisticsInfo = 2;
inline bool CoreToManagerMessage::has_statisticsinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoreToManagerMessage::set_has_statisticsinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoreToManagerMessage::clear_has_statisticsinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoreToManagerMessage::clear_statisticsinfo() {
  if (statisticsinfo_ != NULL) statisticsinfo_->::sm::StatisticsInfo::Clear();
  clear_has_statisticsinfo();
}
inline const ::sm::StatisticsInfo& CoreToManagerMessage::statisticsinfo() const {
  // @@protoc_insertion_point(field_get:sm.CoreToManagerMessage.statisticsInfo)
  return statisticsinfo_ != NULL ? *statisticsinfo_ : *default_instance_->statisticsinfo_;
}
inline ::sm::StatisticsInfo* CoreToManagerMessage::mutable_statisticsinfo() {
  set_has_statisticsinfo();
  if (statisticsinfo_ == NULL) {
    statisticsinfo_ = new ::sm::StatisticsInfo;
  }
  // @@protoc_insertion_point(field_mutable:sm.CoreToManagerMessage.statisticsInfo)
  return statisticsinfo_;
}
inline ::sm::StatisticsInfo* CoreToManagerMessage::release_statisticsinfo() {
  // @@protoc_insertion_point(field_release:sm.CoreToManagerMessage.statisticsInfo)
  clear_has_statisticsinfo();
  ::sm::StatisticsInfo* temp = statisticsinfo_;
  statisticsinfo_ = NULL;
  return temp;
}
inline void CoreToManagerMessage::set_allocated_statisticsinfo(::sm::StatisticsInfo* statisticsinfo) {
  delete statisticsinfo_;
  statisticsinfo_ = statisticsinfo;
  if (statisticsinfo) {
    set_has_statisticsinfo();
  } else {
    clear_has_statisticsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.CoreToManagerMessage.statisticsInfo)
}

// -------------------------------------------------------------------

// OptionsInfo

// required bool transparentStructures = 1;
inline bool OptionsInfo::has_transparentstructures() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OptionsInfo::set_has_transparentstructures() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OptionsInfo::clear_has_transparentstructures() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OptionsInfo::clear_transparentstructures() {
  transparentstructures_ = false;
  clear_has_transparentstructures();
}
inline bool OptionsInfo::transparentstructures() const {
  // @@protoc_insertion_point(field_get:sm.OptionsInfo.transparentStructures)
  return transparentstructures_;
}
inline void OptionsInfo::set_transparentstructures(bool value) {
  set_has_transparentstructures();
  transparentstructures_ = value;
  // @@protoc_insertion_point(field_set:sm.OptionsInfo.transparentStructures)
}

// required bool dynamicRendering = 2;
inline bool OptionsInfo::has_dynamicrendering() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OptionsInfo::set_has_dynamicrendering() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OptionsInfo::clear_has_dynamicrendering() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OptionsInfo::clear_dynamicrendering() {
  dynamicrendering_ = false;
  clear_has_dynamicrendering();
}
inline bool OptionsInfo::dynamicrendering() const {
  // @@protoc_insertion_point(field_get:sm.OptionsInfo.dynamicRendering)
  return dynamicrendering_;
}
inline void OptionsInfo::set_dynamicrendering(bool value) {
  set_has_dynamicrendering();
  dynamicrendering_ = value;
  // @@protoc_insertion_point(field_set:sm.OptionsInfo.dynamicRendering)
}

// required bool showLabels = 3;
inline bool OptionsInfo::has_showlabels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OptionsInfo::set_has_showlabels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OptionsInfo::clear_has_showlabels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OptionsInfo::clear_showlabels() {
  showlabels_ = false;
  clear_has_showlabels();
}
inline bool OptionsInfo::showlabels() const {
  // @@protoc_insertion_point(field_get:sm.OptionsInfo.showLabels)
  return showlabels_;
}
inline void OptionsInfo::set_showlabels(bool value) {
  set_has_showlabels();
  showlabels_ = value;
  // @@protoc_insertion_point(field_set:sm.OptionsInfo.showLabels)
}

// required double mouseSensitivity = 4;
inline bool OptionsInfo::has_mousesensitivity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OptionsInfo::set_has_mousesensitivity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OptionsInfo::clear_has_mousesensitivity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OptionsInfo::clear_mousesensitivity() {
  mousesensitivity_ = 0;
  clear_has_mousesensitivity();
}
inline double OptionsInfo::mousesensitivity() const {
  // @@protoc_insertion_point(field_get:sm.OptionsInfo.mouseSensitivity)
  return mousesensitivity_;
}
inline void OptionsInfo::set_mousesensitivity(double value) {
  set_has_mousesensitivity();
  mousesensitivity_ = value;
  // @@protoc_insertion_point(field_set:sm.OptionsInfo.mouseSensitivity)
}

// -------------------------------------------------------------------

// TypesFilter

// map<string, bool> selectedTypes = 1;
inline int TypesFilter::selectedtypes_size() const {
  return selectedtypes_.size();
}
inline void TypesFilter::clear_selectedtypes() {
  selectedtypes_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, bool >&
TypesFilter::selectedtypes() const {
  // @@protoc_insertion_point(field_map:sm.TypesFilter.selectedTypes)
  return selectedtypes_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, bool >*
TypesFilter::mutable_selectedtypes() {
  // @@protoc_insertion_point(field_mutable_map:sm.TypesFilter.selectedTypes)
  return selectedtypes_.MutableMap();
}

// -------------------------------------------------------------------

// GroupsFilter

// map<string, bool> selectedGroups = 1;
inline int GroupsFilter::selectedgroups_size() const {
  return selectedgroups_.size();
}
inline void GroupsFilter::clear_selectedgroups() {
  selectedgroups_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, bool >&
GroupsFilter::selectedgroups() const {
  // @@protoc_insertion_point(field_map:sm.GroupsFilter.selectedGroups)
  return selectedgroups_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, bool >*
GroupsFilter::mutable_selectedgroups() {
  // @@protoc_insertion_point(field_mutable_map:sm.GroupsFilter.selectedGroups)
  return selectedgroups_.MutableMap();
}

// -------------------------------------------------------------------

// QualityCondition

// optional double leftValue = 1;
inline bool QualityCondition::has_leftvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QualityCondition::set_has_leftvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QualityCondition::clear_has_leftvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QualityCondition::clear_leftvalue() {
  leftvalue_ = 0;
  clear_has_leftvalue();
}
inline double QualityCondition::leftvalue() const {
  // @@protoc_insertion_point(field_get:sm.QualityCondition.leftValue)
  return leftvalue_;
}
inline void QualityCondition::set_leftvalue(double value) {
  set_has_leftvalue();
  leftvalue_ = value;
  // @@protoc_insertion_point(field_set:sm.QualityCondition.leftValue)
}

// optional .sm.ComparisonOperator leftOperator = 2;
inline bool QualityCondition::has_leftoperator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QualityCondition::set_has_leftoperator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QualityCondition::clear_has_leftoperator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QualityCondition::clear_leftoperator() {
  leftoperator_ = 1;
  clear_has_leftoperator();
}
inline ::sm::ComparisonOperator QualityCondition::leftoperator() const {
  // @@protoc_insertion_point(field_get:sm.QualityCondition.leftOperator)
  return static_cast< ::sm::ComparisonOperator >(leftoperator_);
}
inline void QualityCondition::set_leftoperator(::sm::ComparisonOperator value) {
  assert(::sm::ComparisonOperator_IsValid(value));
  set_has_leftoperator();
  leftoperator_ = value;
  // @@protoc_insertion_point(field_set:sm.QualityCondition.leftOperator)
}

// optional .sm.ComparisonOperator rightOperator = 3;
inline bool QualityCondition::has_rightoperator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QualityCondition::set_has_rightoperator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QualityCondition::clear_has_rightoperator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QualityCondition::clear_rightoperator() {
  rightoperator_ = 1;
  clear_has_rightoperator();
}
inline ::sm::ComparisonOperator QualityCondition::rightoperator() const {
  // @@protoc_insertion_point(field_get:sm.QualityCondition.rightOperator)
  return static_cast< ::sm::ComparisonOperator >(rightoperator_);
}
inline void QualityCondition::set_rightoperator(::sm::ComparisonOperator value) {
  assert(::sm::ComparisonOperator_IsValid(value));
  set_has_rightoperator();
  rightoperator_ = value;
  // @@protoc_insertion_point(field_set:sm.QualityCondition.rightOperator)
}

// optional double rightValue = 4;
inline bool QualityCondition::has_rightvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QualityCondition::set_has_rightvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QualityCondition::clear_has_rightvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QualityCondition::clear_rightvalue() {
  rightvalue_ = 0;
  clear_has_rightvalue();
}
inline double QualityCondition::rightvalue() const {
  // @@protoc_insertion_point(field_get:sm.QualityCondition.rightValue)
  return rightvalue_;
}
inline void QualityCondition::set_rightvalue(double value) {
  set_has_rightvalue();
  rightvalue_ = value;
  // @@protoc_insertion_point(field_set:sm.QualityCondition.rightValue)
}

// -------------------------------------------------------------------

// QualityFilter

// repeated .sm.QualityCondition qualityCondition = 1;
inline int QualityFilter::qualitycondition_size() const {
  return qualitycondition_.size();
}
inline void QualityFilter::clear_qualitycondition() {
  qualitycondition_.Clear();
}
inline const ::sm::QualityCondition& QualityFilter::qualitycondition(int index) const {
  // @@protoc_insertion_point(field_get:sm.QualityFilter.qualityCondition)
  return qualitycondition_.Get(index);
}
inline ::sm::QualityCondition* QualityFilter::mutable_qualitycondition(int index) {
  // @@protoc_insertion_point(field_mutable:sm.QualityFilter.qualityCondition)
  return qualitycondition_.Mutable(index);
}
inline ::sm::QualityCondition* QualityFilter::add_qualitycondition() {
  // @@protoc_insertion_point(field_add:sm.QualityFilter.qualityCondition)
  return qualitycondition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sm::QualityCondition >*
QualityFilter::mutable_qualitycondition() {
  // @@protoc_insertion_point(field_mutable_list:sm.QualityFilter.qualityCondition)
  return &qualitycondition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sm::QualityCondition >&
QualityFilter::qualitycondition() const {
  // @@protoc_insertion_point(field_list:sm.QualityFilter.qualityCondition)
  return qualitycondition_;
}

// -------------------------------------------------------------------

// CoordinatesCondition

// required double xValue = 1;
inline bool CoordinatesCondition::has_xvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordinatesCondition::set_has_xvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordinatesCondition::clear_has_xvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordinatesCondition::clear_xvalue() {
  xvalue_ = 0;
  clear_has_xvalue();
}
inline double CoordinatesCondition::xvalue() const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesCondition.xValue)
  return xvalue_;
}
inline void CoordinatesCondition::set_xvalue(double value) {
  set_has_xvalue();
  xvalue_ = value;
  // @@protoc_insertion_point(field_set:sm.CoordinatesCondition.xValue)
}

// required double yValue = 2;
inline bool CoordinatesCondition::has_yvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordinatesCondition::set_has_yvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordinatesCondition::clear_has_yvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordinatesCondition::clear_yvalue() {
  yvalue_ = 0;
  clear_has_yvalue();
}
inline double CoordinatesCondition::yvalue() const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesCondition.yValue)
  return yvalue_;
}
inline void CoordinatesCondition::set_yvalue(double value) {
  set_has_yvalue();
  yvalue_ = value;
  // @@protoc_insertion_point(field_set:sm.CoordinatesCondition.yValue)
}

// required double zValue = 3;
inline bool CoordinatesCondition::has_zvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoordinatesCondition::set_has_zvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoordinatesCondition::clear_has_zvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoordinatesCondition::clear_zvalue() {
  zvalue_ = 0;
  clear_has_zvalue();
}
inline double CoordinatesCondition::zvalue() const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesCondition.zValue)
  return zvalue_;
}
inline void CoordinatesCondition::set_zvalue(double value) {
  set_has_zvalue();
  zvalue_ = value;
  // @@protoc_insertion_point(field_set:sm.CoordinatesCondition.zValue)
}

// required .sm.ComparisonOperator coordinatesOperator = 4;
inline bool CoordinatesCondition::has_coordinatesoperator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoordinatesCondition::set_has_coordinatesoperator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoordinatesCondition::clear_has_coordinatesoperator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoordinatesCondition::clear_coordinatesoperator() {
  coordinatesoperator_ = 1;
  clear_has_coordinatesoperator();
}
inline ::sm::ComparisonOperator CoordinatesCondition::coordinatesoperator() const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesCondition.coordinatesOperator)
  return static_cast< ::sm::ComparisonOperator >(coordinatesoperator_);
}
inline void CoordinatesCondition::set_coordinatesoperator(::sm::ComparisonOperator value) {
  assert(::sm::ComparisonOperator_IsValid(value));
  set_has_coordinatesoperator();
  coordinatesoperator_ = value;
  // @@protoc_insertion_point(field_set:sm.CoordinatesCondition.coordinatesOperator)
}

// required double constant = 5;
inline bool CoordinatesCondition::has_constant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CoordinatesCondition::set_has_constant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CoordinatesCondition::clear_has_constant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CoordinatesCondition::clear_constant() {
  constant_ = 0;
  clear_has_constant();
}
inline double CoordinatesCondition::constant() const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesCondition.constant)
  return constant_;
}
inline void CoordinatesCondition::set_constant(double value) {
  set_has_constant();
  constant_ = value;
  // @@protoc_insertion_point(field_set:sm.CoordinatesCondition.constant)
}

// -------------------------------------------------------------------

// CoordinatesFilter

// repeated .sm.CoordinatesCondition coordinatesCondition = 1;
inline int CoordinatesFilter::coordinatescondition_size() const {
  return coordinatescondition_.size();
}
inline void CoordinatesFilter::clear_coordinatescondition() {
  coordinatescondition_.Clear();
}
inline const ::sm::CoordinatesCondition& CoordinatesFilter::coordinatescondition(int index) const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesFilter.coordinatesCondition)
  return coordinatescondition_.Get(index);
}
inline ::sm::CoordinatesCondition* CoordinatesFilter::mutable_coordinatescondition(int index) {
  // @@protoc_insertion_point(field_mutable:sm.CoordinatesFilter.coordinatesCondition)
  return coordinatescondition_.Mutable(index);
}
inline ::sm::CoordinatesCondition* CoordinatesFilter::add_coordinatescondition() {
  // @@protoc_insertion_point(field_add:sm.CoordinatesFilter.coordinatesCondition)
  return coordinatescondition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sm::CoordinatesCondition >*
CoordinatesFilter::mutable_coordinatescondition() {
  // @@protoc_insertion_point(field_mutable_list:sm.CoordinatesFilter.coordinatesCondition)
  return &coordinatescondition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sm::CoordinatesCondition >&
CoordinatesFilter::coordinatescondition() const {
  // @@protoc_insertion_point(field_list:sm.CoordinatesFilter.coordinatesCondition)
  return coordinatescondition_;
}

// optional .sm.CoordinatesFilter.Conjunction conjunction = 2;
inline bool CoordinatesFilter::has_conjunction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordinatesFilter::set_has_conjunction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordinatesFilter::clear_has_conjunction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordinatesFilter::clear_conjunction() {
  conjunction_ = 1;
  clear_has_conjunction();
}
inline ::sm::CoordinatesFilter_Conjunction CoordinatesFilter::conjunction() const {
  // @@protoc_insertion_point(field_get:sm.CoordinatesFilter.conjunction)
  return static_cast< ::sm::CoordinatesFilter_Conjunction >(conjunction_);
}
inline void CoordinatesFilter::set_conjunction(::sm::CoordinatesFilter_Conjunction value) {
  assert(::sm::CoordinatesFilter_Conjunction_IsValid(value));
  set_has_conjunction();
  conjunction_ = value;
  // @@protoc_insertion_point(field_set:sm.CoordinatesFilter.conjunction)
}

// -------------------------------------------------------------------

// ManagerToCoreMessage

// required .sm.ManagerToCoreMessage.MTCMessageType messageType = 1;
inline bool ManagerToCoreMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagerToCoreMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagerToCoreMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManagerToCoreMessage::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::sm::ManagerToCoreMessage_MTCMessageType ManagerToCoreMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:sm.ManagerToCoreMessage.messageType)
  return static_cast< ::sm::ManagerToCoreMessage_MTCMessageType >(messagetype_);
}
inline void ManagerToCoreMessage::set_messagetype(::sm::ManagerToCoreMessage_MTCMessageType value) {
  assert(::sm::ManagerToCoreMessage_MTCMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:sm.ManagerToCoreMessage.messageType)
}

// optional .sm.OptionsInfo optionsInfo = 2;
inline bool ManagerToCoreMessage::has_optionsinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManagerToCoreMessage::set_has_optionsinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManagerToCoreMessage::clear_has_optionsinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManagerToCoreMessage::clear_optionsinfo() {
  if (optionsinfo_ != NULL) optionsinfo_->::sm::OptionsInfo::Clear();
  clear_has_optionsinfo();
}
inline const ::sm::OptionsInfo& ManagerToCoreMessage::optionsinfo() const {
  // @@protoc_insertion_point(field_get:sm.ManagerToCoreMessage.optionsInfo)
  return optionsinfo_ != NULL ? *optionsinfo_ : *default_instance_->optionsinfo_;
}
inline ::sm::OptionsInfo* ManagerToCoreMessage::mutable_optionsinfo() {
  set_has_optionsinfo();
  if (optionsinfo_ == NULL) {
    optionsinfo_ = new ::sm::OptionsInfo;
  }
  // @@protoc_insertion_point(field_mutable:sm.ManagerToCoreMessage.optionsInfo)
  return optionsinfo_;
}
inline ::sm::OptionsInfo* ManagerToCoreMessage::release_optionsinfo() {
  // @@protoc_insertion_point(field_release:sm.ManagerToCoreMessage.optionsInfo)
  clear_has_optionsinfo();
  ::sm::OptionsInfo* temp = optionsinfo_;
  optionsinfo_ = NULL;
  return temp;
}
inline void ManagerToCoreMessage::set_allocated_optionsinfo(::sm::OptionsInfo* optionsinfo) {
  delete optionsinfo_;
  optionsinfo_ = optionsinfo;
  if (optionsinfo) {
    set_has_optionsinfo();
  } else {
    clear_has_optionsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.ManagerToCoreMessage.optionsInfo)
}

// optional .sm.GroupsFilter groupsFilter = 3;
inline bool ManagerToCoreMessage::has_groupsfilter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManagerToCoreMessage::set_has_groupsfilter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManagerToCoreMessage::clear_has_groupsfilter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManagerToCoreMessage::clear_groupsfilter() {
  if (groupsfilter_ != NULL) groupsfilter_->::sm::GroupsFilter::Clear();
  clear_has_groupsfilter();
}
inline const ::sm::GroupsFilter& ManagerToCoreMessage::groupsfilter() const {
  // @@protoc_insertion_point(field_get:sm.ManagerToCoreMessage.groupsFilter)
  return groupsfilter_ != NULL ? *groupsfilter_ : *default_instance_->groupsfilter_;
}
inline ::sm::GroupsFilter* ManagerToCoreMessage::mutable_groupsfilter() {
  set_has_groupsfilter();
  if (groupsfilter_ == NULL) {
    groupsfilter_ = new ::sm::GroupsFilter;
  }
  // @@protoc_insertion_point(field_mutable:sm.ManagerToCoreMessage.groupsFilter)
  return groupsfilter_;
}
inline ::sm::GroupsFilter* ManagerToCoreMessage::release_groupsfilter() {
  // @@protoc_insertion_point(field_release:sm.ManagerToCoreMessage.groupsFilter)
  clear_has_groupsfilter();
  ::sm::GroupsFilter* temp = groupsfilter_;
  groupsfilter_ = NULL;
  return temp;
}
inline void ManagerToCoreMessage::set_allocated_groupsfilter(::sm::GroupsFilter* groupsfilter) {
  delete groupsfilter_;
  groupsfilter_ = groupsfilter;
  if (groupsfilter) {
    set_has_groupsfilter();
  } else {
    clear_has_groupsfilter();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.ManagerToCoreMessage.groupsFilter)
}

// optional .sm.TypesFilter typesFilter = 4;
inline bool ManagerToCoreMessage::has_typesfilter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManagerToCoreMessage::set_has_typesfilter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManagerToCoreMessage::clear_has_typesfilter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManagerToCoreMessage::clear_typesfilter() {
  if (typesfilter_ != NULL) typesfilter_->::sm::TypesFilter::Clear();
  clear_has_typesfilter();
}
inline const ::sm::TypesFilter& ManagerToCoreMessage::typesfilter() const {
  // @@protoc_insertion_point(field_get:sm.ManagerToCoreMessage.typesFilter)
  return typesfilter_ != NULL ? *typesfilter_ : *default_instance_->typesfilter_;
}
inline ::sm::TypesFilter* ManagerToCoreMessage::mutable_typesfilter() {
  set_has_typesfilter();
  if (typesfilter_ == NULL) {
    typesfilter_ = new ::sm::TypesFilter;
  }
  // @@protoc_insertion_point(field_mutable:sm.ManagerToCoreMessage.typesFilter)
  return typesfilter_;
}
inline ::sm::TypesFilter* ManagerToCoreMessage::release_typesfilter() {
  // @@protoc_insertion_point(field_release:sm.ManagerToCoreMessage.typesFilter)
  clear_has_typesfilter();
  ::sm::TypesFilter* temp = typesfilter_;
  typesfilter_ = NULL;
  return temp;
}
inline void ManagerToCoreMessage::set_allocated_typesfilter(::sm::TypesFilter* typesfilter) {
  delete typesfilter_;
  typesfilter_ = typesfilter;
  if (typesfilter) {
    set_has_typesfilter();
  } else {
    clear_has_typesfilter();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.ManagerToCoreMessage.typesFilter)
}

// optional .sm.QualityFilter qualityFilter = 5;
inline bool ManagerToCoreMessage::has_qualityfilter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ManagerToCoreMessage::set_has_qualityfilter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ManagerToCoreMessage::clear_has_qualityfilter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ManagerToCoreMessage::clear_qualityfilter() {
  if (qualityfilter_ != NULL) qualityfilter_->::sm::QualityFilter::Clear();
  clear_has_qualityfilter();
}
inline const ::sm::QualityFilter& ManagerToCoreMessage::qualityfilter() const {
  // @@protoc_insertion_point(field_get:sm.ManagerToCoreMessage.qualityFilter)
  return qualityfilter_ != NULL ? *qualityfilter_ : *default_instance_->qualityfilter_;
}
inline ::sm::QualityFilter* ManagerToCoreMessage::mutable_qualityfilter() {
  set_has_qualityfilter();
  if (qualityfilter_ == NULL) {
    qualityfilter_ = new ::sm::QualityFilter;
  }
  // @@protoc_insertion_point(field_mutable:sm.ManagerToCoreMessage.qualityFilter)
  return qualityfilter_;
}
inline ::sm::QualityFilter* ManagerToCoreMessage::release_qualityfilter() {
  // @@protoc_insertion_point(field_release:sm.ManagerToCoreMessage.qualityFilter)
  clear_has_qualityfilter();
  ::sm::QualityFilter* temp = qualityfilter_;
  qualityfilter_ = NULL;
  return temp;
}
inline void ManagerToCoreMessage::set_allocated_qualityfilter(::sm::QualityFilter* qualityfilter) {
  delete qualityfilter_;
  qualityfilter_ = qualityfilter;
  if (qualityfilter) {
    set_has_qualityfilter();
  } else {
    clear_has_qualityfilter();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.ManagerToCoreMessage.qualityFilter)
}

// optional .sm.CoordinatesFilter coordinatesFilter = 6;
inline bool ManagerToCoreMessage::has_coordinatesfilter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ManagerToCoreMessage::set_has_coordinatesfilter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ManagerToCoreMessage::clear_has_coordinatesfilter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ManagerToCoreMessage::clear_coordinatesfilter() {
  if (coordinatesfilter_ != NULL) coordinatesfilter_->::sm::CoordinatesFilter::Clear();
  clear_has_coordinatesfilter();
}
inline const ::sm::CoordinatesFilter& ManagerToCoreMessage::coordinatesfilter() const {
  // @@protoc_insertion_point(field_get:sm.ManagerToCoreMessage.coordinatesFilter)
  return coordinatesfilter_ != NULL ? *coordinatesfilter_ : *default_instance_->coordinatesfilter_;
}
inline ::sm::CoordinatesFilter* ManagerToCoreMessage::mutable_coordinatesfilter() {
  set_has_coordinatesfilter();
  if (coordinatesfilter_ == NULL) {
    coordinatesfilter_ = new ::sm::CoordinatesFilter;
  }
  // @@protoc_insertion_point(field_mutable:sm.ManagerToCoreMessage.coordinatesFilter)
  return coordinatesfilter_;
}
inline ::sm::CoordinatesFilter* ManagerToCoreMessage::release_coordinatesfilter() {
  // @@protoc_insertion_point(field_release:sm.ManagerToCoreMessage.coordinatesFilter)
  clear_has_coordinatesfilter();
  ::sm::CoordinatesFilter* temp = coordinatesfilter_;
  coordinatesfilter_ = NULL;
  return temp;
}
inline void ManagerToCoreMessage::set_allocated_coordinatesfilter(::sm::CoordinatesFilter* coordinatesfilter) {
  delete coordinatesfilter_;
  coordinatesfilter_ = coordinatesfilter;
  if (coordinatesfilter) {
    set_has_coordinatesfilter();
  } else {
    clear_has_coordinatesfilter();
  }
  // @@protoc_insertion_point(field_set_allocated:sm.ManagerToCoreMessage.coordinatesFilter)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sm

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sm::CoreToManagerMessage_CTMMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sm::CoreToManagerMessage_CTMMessageType>() {
  return ::sm::CoreToManagerMessage_CTMMessageType_descriptor();
}
template <> struct is_proto_enum< ::sm::CoordinatesFilter_Conjunction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sm::CoordinatesFilter_Conjunction>() {
  return ::sm::CoordinatesFilter_Conjunction_descriptor();
}
template <> struct is_proto_enum< ::sm::ManagerToCoreMessage_MTCMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sm::ManagerToCoreMessage_MTCMessageType>() {
  return ::sm::ManagerToCoreMessage_MTCMessageType_descriptor();
}
template <> struct is_proto_enum< ::sm::ComparisonOperator> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sm::ComparisonOperator>() {
  return ::sm::ComparisonOperator_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_communication_2eproto__INCLUDED
