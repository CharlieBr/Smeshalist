// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structs.proto

#ifndef PROTOBUF_structs_2eproto__INCLUDED
#define PROTOBUF_structs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace structDefinitions {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_structs_2eproto();
void protobuf_AssignDesc_structs_2eproto();
void protobuf_ShutdownFile_structs_2eproto();

class Block;
class BlockSet;
class DataPackage;
class Edge;
class EdgeSet;
class MessageInfo;
class Point2D;
class Point2DSet;
class Point3D;
class Point3DSet;
class Properties;
class TriangleFace;
class TriangleFaceSet;
class Vertex;
class VertexSet;

enum MessageInfo_Type {
  MessageInfo_Type_DATA = 1,
  MessageInfo_Type_RENDER = 2,
  MessageInfo_Type_BREAKPOINT = 3
};
bool MessageInfo_Type_IsValid(int value);
const MessageInfo_Type MessageInfo_Type_Type_MIN = MessageInfo_Type_DATA;
const MessageInfo_Type MessageInfo_Type_Type_MAX = MessageInfo_Type_BREAKPOINT;
const int MessageInfo_Type_Type_ARRAYSIZE = MessageInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageInfo_Type_descriptor();
inline const ::std::string& MessageInfo_Type_Name(MessageInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageInfo_Type_descriptor(), value);
}
inline bool MessageInfo_Type_Parse(
    const ::std::string& name, MessageInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageInfo_Type>(
    MessageInfo_Type_descriptor(), name, value);
}
// ===================================================================

class Properties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Properties) */ {
 public:
  Properties();
  virtual ~Properties();

  Properties(const Properties& from);

  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties& default_instance();

  void Swap(Properties* other);

  // implements Message ----------------------------------------------

  inline Properties* New() const { return New(NULL); }

  Properties* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties& from);
  void MergeFrom(const Properties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Properties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double quality = 1;
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 1;
  double quality() const;
  void set_quality(double value);

  // optional string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional int32 groupId = 3;
  bool has_groupid() const;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 3;
  ::google::protobuf::int32 groupid() const;
  void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:structDefinitions.Properties)
 private:
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double quality_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::int32 groupid_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Properties* default_instance_;
};
// -------------------------------------------------------------------

class Point2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Point2D) */ {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2D& default_instance();

  void Swap(Point2D* other);

  // implements Message ----------------------------------------------

  inline Point2D* New() const { return New(NULL); }

  Point2D* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional .structDefinitions.Properties prop = 3;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 3;
  const ::structDefinitions::Properties& prop() const;
  ::structDefinitions::Properties* mutable_prop();
  ::structDefinitions::Properties* release_prop();
  void set_allocated_prop(::structDefinitions::Properties* prop);

  // @@protoc_insertion_point(class_scope:structDefinitions.Point2D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  ::structDefinitions::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Point2D* default_instance_;
};
// -------------------------------------------------------------------

class Point2DSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Point2DSet) */ {
 public:
  Point2DSet();
  virtual ~Point2DSet();

  Point2DSet(const Point2DSet& from);

  inline Point2DSet& operator=(const Point2DSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2DSet& default_instance();

  void Swap(Point2DSet* other);

  // implements Message ----------------------------------------------

  inline Point2DSet* New() const { return New(NULL); }

  Point2DSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2DSet& from);
  void MergeFrom(const Point2DSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point2DSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .structDefinitions.Point2D points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::structDefinitions::Point2D& points(int index) const;
  ::structDefinitions::Point2D* mutable_points(int index);
  ::structDefinitions::Point2D* add_points();
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point2D >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point2D >&
      points() const;

  // @@protoc_insertion_point(class_scope:structDefinitions.Point2DSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point2D > points_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Point2DSet* default_instance_;
};
// -------------------------------------------------------------------

class Point3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Point3D) */ {
 public:
  Point3D();
  virtual ~Point3D();

  Point3D(const Point3D& from);

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3D& default_instance();

  void Swap(Point3D* other);

  // implements Message ----------------------------------------------

  inline Point3D* New() const { return New(NULL); }

  Point3D* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point3D& from);
  void MergeFrom(const Point3D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional .structDefinitions.Properties prop = 4;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 4;
  const ::structDefinitions::Properties& prop() const;
  ::structDefinitions::Properties* mutable_prop();
  ::structDefinitions::Properties* release_prop();
  void set_allocated_prop(::structDefinitions::Properties* prop);

  // @@protoc_insertion_point(class_scope:structDefinitions.Point3D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  ::structDefinitions::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Point3D* default_instance_;
};
// -------------------------------------------------------------------

class Point3DSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Point3DSet) */ {
 public:
  Point3DSet();
  virtual ~Point3DSet();

  Point3DSet(const Point3DSet& from);

  inline Point3DSet& operator=(const Point3DSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3DSet& default_instance();

  void Swap(Point3DSet* other);

  // implements Message ----------------------------------------------

  inline Point3DSet* New() const { return New(NULL); }

  Point3DSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point3DSet& from);
  void MergeFrom(const Point3DSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point3DSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .structDefinitions.Point3D points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::structDefinitions::Point3D& points(int index) const;
  ::structDefinitions::Point3D* mutable_points(int index);
  ::structDefinitions::Point3D* add_points();
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point3D >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point3D >&
      points() const;

  // @@protoc_insertion_point(class_scope:structDefinitions.Point3DSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point3D > points_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Point3DSet* default_instance_;
};
// -------------------------------------------------------------------

class Vertex : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Vertex) */ {
 public:
  Vertex();
  virtual ~Vertex();

  Vertex(const Vertex& from);

  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex& default_instance();

  void Swap(Vertex* other);

  // implements Message ----------------------------------------------

  inline Vertex* New() const { return New(NULL); }

  Vertex* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vertex& from);
  void MergeFrom(const Vertex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vertex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .structDefinitions.Point3D point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::structDefinitions::Point3D& point() const;
  ::structDefinitions::Point3D* mutable_point();
  ::structDefinitions::Point3D* release_point();
  void set_allocated_point(::structDefinitions::Point3D* point);

  // required double number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  double number() const;
  void set_number(double value);

  // optional .structDefinitions.Properties prop = 3;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 3;
  const ::structDefinitions::Properties& prop() const;
  ::structDefinitions::Properties* mutable_prop();
  ::structDefinitions::Properties* release_prop();
  void set_allocated_prop(::structDefinitions::Properties* prop);

  // @@protoc_insertion_point(class_scope:structDefinitions.Vertex)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::structDefinitions::Point3D* point_;
  double number_;
  ::structDefinitions::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Vertex* default_instance_;
};
// -------------------------------------------------------------------

class VertexSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.VertexSet) */ {
 public:
  VertexSet();
  virtual ~VertexSet();

  VertexSet(const VertexSet& from);

  inline VertexSet& operator=(const VertexSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VertexSet& default_instance();

  void Swap(VertexSet* other);

  // implements Message ----------------------------------------------

  inline VertexSet* New() const { return New(NULL); }

  VertexSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VertexSet& from);
  void MergeFrom(const VertexSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VertexSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .structDefinitions.Vertex vertexes = 1;
  int vertexes_size() const;
  void clear_vertexes();
  static const int kVertexesFieldNumber = 1;
  const ::structDefinitions::Vertex& vertexes(int index) const;
  ::structDefinitions::Vertex* mutable_vertexes(int index);
  ::structDefinitions::Vertex* add_vertexes();
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Vertex >*
      mutable_vertexes();
  const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Vertex >&
      vertexes() const;

  // @@protoc_insertion_point(class_scope:structDefinitions.VertexSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Vertex > vertexes_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static VertexSet* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  inline Edge* New() const { return New(NULL); }

  Edge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .structDefinitions.Point3D v1 = 1;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  const ::structDefinitions::Point3D& v1() const;
  ::structDefinitions::Point3D* mutable_v1();
  ::structDefinitions::Point3D* release_v1();
  void set_allocated_v1(::structDefinitions::Point3D* v1);

  // required .structDefinitions.Point3D v2 = 2;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  const ::structDefinitions::Point3D& v2() const;
  ::structDefinitions::Point3D* mutable_v2();
  ::structDefinitions::Point3D* release_v2();
  void set_allocated_v2(::structDefinitions::Point3D* v2);

  // optional .structDefinitions.Properties prop = 3;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 3;
  const ::structDefinitions::Properties& prop() const;
  ::structDefinitions::Properties* mutable_prop();
  ::structDefinitions::Properties* release_prop();
  void set_allocated_prop(::structDefinitions::Properties* prop);

  // @@protoc_insertion_point(class_scope:structDefinitions.Edge)
 private:
  inline void set_has_v1();
  inline void clear_has_v1();
  inline void set_has_v2();
  inline void clear_has_v2();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::structDefinitions::Point3D* v1_;
  ::structDefinitions::Point3D* v2_;
  ::structDefinitions::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class EdgeSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.EdgeSet) */ {
 public:
  EdgeSet();
  virtual ~EdgeSet();

  EdgeSet(const EdgeSet& from);

  inline EdgeSet& operator=(const EdgeSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeSet& default_instance();

  void Swap(EdgeSet* other);

  // implements Message ----------------------------------------------

  inline EdgeSet* New() const { return New(NULL); }

  EdgeSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgeSet& from);
  void MergeFrom(const EdgeSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EdgeSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .structDefinitions.Edge edges = 1;
  int edges_size() const;
  void clear_edges();
  static const int kEdgesFieldNumber = 1;
  const ::structDefinitions::Edge& edges(int index) const;
  ::structDefinitions::Edge* mutable_edges(int index);
  ::structDefinitions::Edge* add_edges();
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Edge >*
      mutable_edges();
  const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Edge >&
      edges() const;

  // @@protoc_insertion_point(class_scope:structDefinitions.EdgeSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Edge > edges_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static EdgeSet* default_instance_;
};
// -------------------------------------------------------------------

class TriangleFace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.TriangleFace) */ {
 public:
  TriangleFace();
  virtual ~TriangleFace();

  TriangleFace(const TriangleFace& from);

  inline TriangleFace& operator=(const TriangleFace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriangleFace& default_instance();

  void Swap(TriangleFace* other);

  // implements Message ----------------------------------------------

  inline TriangleFace* New() const { return New(NULL); }

  TriangleFace* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriangleFace& from);
  void MergeFrom(const TriangleFace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriangleFace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .structDefinitions.Point3D v1 = 1;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  const ::structDefinitions::Point3D& v1() const;
  ::structDefinitions::Point3D* mutable_v1();
  ::structDefinitions::Point3D* release_v1();
  void set_allocated_v1(::structDefinitions::Point3D* v1);

  // required .structDefinitions.Point3D v2 = 2;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  const ::structDefinitions::Point3D& v2() const;
  ::structDefinitions::Point3D* mutable_v2();
  ::structDefinitions::Point3D* release_v2();
  void set_allocated_v2(::structDefinitions::Point3D* v2);

  // required .structDefinitions.Point3D v3 = 3;
  bool has_v3() const;
  void clear_v3();
  static const int kV3FieldNumber = 3;
  const ::structDefinitions::Point3D& v3() const;
  ::structDefinitions::Point3D* mutable_v3();
  ::structDefinitions::Point3D* release_v3();
  void set_allocated_v3(::structDefinitions::Point3D* v3);

  // optional .structDefinitions.Properties prop = 4;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 4;
  const ::structDefinitions::Properties& prop() const;
  ::structDefinitions::Properties* mutable_prop();
  ::structDefinitions::Properties* release_prop();
  void set_allocated_prop(::structDefinitions::Properties* prop);

  // @@protoc_insertion_point(class_scope:structDefinitions.TriangleFace)
 private:
  inline void set_has_v1();
  inline void clear_has_v1();
  inline void set_has_v2();
  inline void clear_has_v2();
  inline void set_has_v3();
  inline void clear_has_v3();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::structDefinitions::Point3D* v1_;
  ::structDefinitions::Point3D* v2_;
  ::structDefinitions::Point3D* v3_;
  ::structDefinitions::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static TriangleFace* default_instance_;
};
// -------------------------------------------------------------------

class TriangleFaceSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.TriangleFaceSet) */ {
 public:
  TriangleFaceSet();
  virtual ~TriangleFaceSet();

  TriangleFaceSet(const TriangleFaceSet& from);

  inline TriangleFaceSet& operator=(const TriangleFaceSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriangleFaceSet& default_instance();

  void Swap(TriangleFaceSet* other);

  // implements Message ----------------------------------------------

  inline TriangleFaceSet* New() const { return New(NULL); }

  TriangleFaceSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriangleFaceSet& from);
  void MergeFrom(const TriangleFaceSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriangleFaceSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .structDefinitions.TriangleFace triangleFaces = 1;
  int trianglefaces_size() const;
  void clear_trianglefaces();
  static const int kTriangleFacesFieldNumber = 1;
  const ::structDefinitions::TriangleFace& trianglefaces(int index) const;
  ::structDefinitions::TriangleFace* mutable_trianglefaces(int index);
  ::structDefinitions::TriangleFace* add_trianglefaces();
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::TriangleFace >*
      mutable_trianglefaces();
  const ::google::protobuf::RepeatedPtrField< ::structDefinitions::TriangleFace >&
      trianglefaces() const;

  // @@protoc_insertion_point(class_scope:structDefinitions.TriangleFaceSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::TriangleFace > trianglefaces_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static TriangleFaceSet* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .structDefinitions.Point3D v1 = 1;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  const ::structDefinitions::Point3D& v1() const;
  ::structDefinitions::Point3D* mutable_v1();
  ::structDefinitions::Point3D* release_v1();
  void set_allocated_v1(::structDefinitions::Point3D* v1);

  // required .structDefinitions.Point3D v2 = 2;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  const ::structDefinitions::Point3D& v2() const;
  ::structDefinitions::Point3D* mutable_v2();
  ::structDefinitions::Point3D* release_v2();
  void set_allocated_v2(::structDefinitions::Point3D* v2);

  // required .structDefinitions.Point3D v3 = 3;
  bool has_v3() const;
  void clear_v3();
  static const int kV3FieldNumber = 3;
  const ::structDefinitions::Point3D& v3() const;
  ::structDefinitions::Point3D* mutable_v3();
  ::structDefinitions::Point3D* release_v3();
  void set_allocated_v3(::structDefinitions::Point3D* v3);

  // required .structDefinitions.Point3D v4 = 4;
  bool has_v4() const;
  void clear_v4();
  static const int kV4FieldNumber = 4;
  const ::structDefinitions::Point3D& v4() const;
  ::structDefinitions::Point3D* mutable_v4();
  ::structDefinitions::Point3D* release_v4();
  void set_allocated_v4(::structDefinitions::Point3D* v4);

  // optional .structDefinitions.Properties prop = 5;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 5;
  const ::structDefinitions::Properties& prop() const;
  ::structDefinitions::Properties* mutable_prop();
  ::structDefinitions::Properties* release_prop();
  void set_allocated_prop(::structDefinitions::Properties* prop);

  // @@protoc_insertion_point(class_scope:structDefinitions.Block)
 private:
  inline void set_has_v1();
  inline void clear_has_v1();
  inline void set_has_v2();
  inline void clear_has_v2();
  inline void set_has_v3();
  inline void clear_has_v3();
  inline void set_has_v4();
  inline void clear_has_v4();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::structDefinitions::Point3D* v1_;
  ::structDefinitions::Point3D* v2_;
  ::structDefinitions::Point3D* v3_;
  ::structDefinitions::Point3D* v4_;
  ::structDefinitions::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class BlockSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.BlockSet) */ {
 public:
  BlockSet();
  virtual ~BlockSet();

  BlockSet(const BlockSet& from);

  inline BlockSet& operator=(const BlockSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockSet& default_instance();

  void Swap(BlockSet* other);

  // implements Message ----------------------------------------------

  inline BlockSet* New() const { return New(NULL); }

  BlockSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockSet& from);
  void MergeFrom(const BlockSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .structDefinitions.Block blocks = 1;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 1;
  const ::structDefinitions::Block& blocks(int index) const;
  ::structDefinitions::Block* mutable_blocks(int index);
  ::structDefinitions::Block* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Block >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Block >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:structDefinitions.BlockSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::structDefinitions::Block > blocks_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static BlockSet* default_instance_;
};
// -------------------------------------------------------------------

class MessageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.MessageInfo) */ {
 public:
  MessageInfo();
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageInfo& default_instance();

  void Swap(MessageInfo* other);

  // implements Message ----------------------------------------------

  inline MessageInfo* New() const { return New(NULL); }

  MessageInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageInfo_Type Type;
  static const Type DATA =
    MessageInfo_Type_DATA;
  static const Type RENDER =
    MessageInfo_Type_RENDER;
  static const Type BREAKPOINT =
    MessageInfo_Type_BREAKPOINT;
  static inline bool Type_IsValid(int value) {
    return MessageInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MessageInfo_Type_Type_MIN;
  static const Type Type_MAX =
    MessageInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MessageInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MessageInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MessageInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MessageInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .structDefinitions.MessageInfo.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::structDefinitions::MessageInfo_Type type() const;
  void set_type(::structDefinitions::MessageInfo_Type value);

  // @@protoc_insertion_point(class_scope:structDefinitions.MessageInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static MessageInfo* default_instance_;
};
// -------------------------------------------------------------------

class DataPackage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:structDefinitions.DataPackage) */ {
 public:
  DataPackage();
  virtual ~DataPackage();

  DataPackage(const DataPackage& from);

  inline DataPackage& operator=(const DataPackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataPackage& default_instance();

  void Swap(DataPackage* other);

  // implements Message ----------------------------------------------

  inline DataPackage* New() const { return New(NULL); }

  DataPackage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataPackage& from);
  void MergeFrom(const DataPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataPackage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .structDefinitions.Point2DSet points2D = 1;
  bool has_points2d() const;
  void clear_points2d();
  static const int kPoints2DFieldNumber = 1;
  const ::structDefinitions::Point2DSet& points2d() const;
  ::structDefinitions::Point2DSet* mutable_points2d();
  ::structDefinitions::Point2DSet* release_points2d();
  void set_allocated_points2d(::structDefinitions::Point2DSet* points2d);

  // optional .structDefinitions.Point3DSet points3D = 2;
  bool has_points3d() const;
  void clear_points3d();
  static const int kPoints3DFieldNumber = 2;
  const ::structDefinitions::Point3DSet& points3d() const;
  ::structDefinitions::Point3DSet* mutable_points3d();
  ::structDefinitions::Point3DSet* release_points3d();
  void set_allocated_points3d(::structDefinitions::Point3DSet* points3d);

  // optional .structDefinitions.VertexSet vertexes = 3;
  bool has_vertexes() const;
  void clear_vertexes();
  static const int kVertexesFieldNumber = 3;
  const ::structDefinitions::VertexSet& vertexes() const;
  ::structDefinitions::VertexSet* mutable_vertexes();
  ::structDefinitions::VertexSet* release_vertexes();
  void set_allocated_vertexes(::structDefinitions::VertexSet* vertexes);

  // optional .structDefinitions.EdgeSet edges = 4;
  bool has_edges() const;
  void clear_edges();
  static const int kEdgesFieldNumber = 4;
  const ::structDefinitions::EdgeSet& edges() const;
  ::structDefinitions::EdgeSet* mutable_edges();
  ::structDefinitions::EdgeSet* release_edges();
  void set_allocated_edges(::structDefinitions::EdgeSet* edges);

  // optional .structDefinitions.TriangleFaceSet faces = 5;
  bool has_faces() const;
  void clear_faces();
  static const int kFacesFieldNumber = 5;
  const ::structDefinitions::TriangleFaceSet& faces() const;
  ::structDefinitions::TriangleFaceSet* mutable_faces();
  ::structDefinitions::TriangleFaceSet* release_faces();
  void set_allocated_faces(::structDefinitions::TriangleFaceSet* faces);

  // optional .structDefinitions.BlockSet blocks = 6;
  bool has_blocks() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 6;
  const ::structDefinitions::BlockSet& blocks() const;
  ::structDefinitions::BlockSet* mutable_blocks();
  ::structDefinitions::BlockSet* release_blocks();
  void set_allocated_blocks(::structDefinitions::BlockSet* blocks);

  // required bool endOfData = 7;
  bool has_endofdata() const;
  void clear_endofdata();
  static const int kEndOfDataFieldNumber = 7;
  bool endofdata() const;
  void set_endofdata(bool value);

  // @@protoc_insertion_point(class_scope:structDefinitions.DataPackage)
 private:
  inline void set_has_points2d();
  inline void clear_has_points2d();
  inline void set_has_points3d();
  inline void clear_has_points3d();
  inline void set_has_vertexes();
  inline void clear_has_vertexes();
  inline void set_has_edges();
  inline void clear_has_edges();
  inline void set_has_faces();
  inline void clear_has_faces();
  inline void set_has_blocks();
  inline void clear_has_blocks();
  inline void set_has_endofdata();
  inline void clear_has_endofdata();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::structDefinitions::Point2DSet* points2d_;
  ::structDefinitions::Point3DSet* points3d_;
  ::structDefinitions::VertexSet* vertexes_;
  ::structDefinitions::EdgeSet* edges_;
  ::structDefinitions::TriangleFaceSet* faces_;
  ::structDefinitions::BlockSet* blocks_;
  bool endofdata_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static DataPackage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Properties

// optional double quality = 1;
inline bool Properties::has_quality() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Properties::set_has_quality() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Properties::clear_has_quality() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Properties::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double Properties::quality() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Properties.quality)
  return quality_;
}
inline void Properties::set_quality(double value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Properties.quality)
}

// optional string label = 2;
inline bool Properties::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Properties::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Properties::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Properties::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& Properties::label() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Properties.label)
  return label_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Properties::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:structDefinitions.Properties.label)
}
inline void Properties::set_label(const char* value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:structDefinitions.Properties.label)
}
inline void Properties::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:structDefinitions.Properties.label)
}
inline ::std::string* Properties::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:structDefinitions.Properties.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Properties::release_label() {
  // @@protoc_insertion_point(field_release:structDefinitions.Properties.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Properties::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Properties.label)
}

// optional int32 groupId = 3;
inline bool Properties::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Properties::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Properties::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Properties::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 Properties::groupid() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Properties.groupId)
  return groupid_;
}
inline void Properties::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Properties.groupId)
}

// -------------------------------------------------------------------

// Point2D

// required double x = 1;
inline bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point2D::x() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point2D.x)
  return x_;
}
inline void Point2D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Point2D.x)
}

// required double y = 2;
inline bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point2D::y() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point2D.y)
  return y_;
}
inline void Point2D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Point2D.y)
}

// optional .structDefinitions.Properties prop = 3;
inline bool Point2D::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point2D::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point2D::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point2D::clear_prop() {
  if (prop_ != NULL) prop_->::structDefinitions::Properties::Clear();
  clear_has_prop();
}
inline const ::structDefinitions::Properties& Point2D::prop() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point2D.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::structDefinitions::Properties* Point2D::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::structDefinitions::Properties;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Point2D.prop)
  return prop_;
}
inline ::structDefinitions::Properties* Point2D::release_prop() {
  // @@protoc_insertion_point(field_release:structDefinitions.Point2D.prop)
  clear_has_prop();
  ::structDefinitions::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Point2D::set_allocated_prop(::structDefinitions::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Point2D.prop)
}

// -------------------------------------------------------------------

// Point2DSet

// repeated .structDefinitions.Point2D points = 1;
inline int Point2DSet::points_size() const {
  return points_.size();
}
inline void Point2DSet::clear_points() {
  points_.Clear();
}
inline const ::structDefinitions::Point2D& Point2DSet::points(int index) const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point2DSet.points)
  return points_.Get(index);
}
inline ::structDefinitions::Point2D* Point2DSet::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:structDefinitions.Point2DSet.points)
  return points_.Mutable(index);
}
inline ::structDefinitions::Point2D* Point2DSet::add_points() {
  // @@protoc_insertion_point(field_add:structDefinitions.Point2DSet.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point2D >*
Point2DSet::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:structDefinitions.Point2DSet.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point2D >&
Point2DSet::points() const {
  // @@protoc_insertion_point(field_list:structDefinitions.Point2DSet.points)
  return points_;
}

// -------------------------------------------------------------------

// Point3D

// required double x = 1;
inline bool Point3D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point3D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point3D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point3D.x)
  return x_;
}
inline void Point3D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Point3D.x)
}

// required double y = 2;
inline bool Point3D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point3D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point3D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point3D.y)
  return y_;
}
inline void Point3D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Point3D.y)
}

// required double z = 3;
inline bool Point3D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point3D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point3D::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point3D.z)
  return z_;
}
inline void Point3D::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Point3D.z)
}

// optional .structDefinitions.Properties prop = 4;
inline bool Point3D::has_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Point3D::set_has_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Point3D::clear_has_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Point3D::clear_prop() {
  if (prop_ != NULL) prop_->::structDefinitions::Properties::Clear();
  clear_has_prop();
}
inline const ::structDefinitions::Properties& Point3D::prop() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point3D.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::structDefinitions::Properties* Point3D::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::structDefinitions::Properties;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Point3D.prop)
  return prop_;
}
inline ::structDefinitions::Properties* Point3D::release_prop() {
  // @@protoc_insertion_point(field_release:structDefinitions.Point3D.prop)
  clear_has_prop();
  ::structDefinitions::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Point3D::set_allocated_prop(::structDefinitions::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Point3D.prop)
}

// -------------------------------------------------------------------

// Point3DSet

// repeated .structDefinitions.Point3D points = 1;
inline int Point3DSet::points_size() const {
  return points_.size();
}
inline void Point3DSet::clear_points() {
  points_.Clear();
}
inline const ::structDefinitions::Point3D& Point3DSet::points(int index) const {
  // @@protoc_insertion_point(field_get:structDefinitions.Point3DSet.points)
  return points_.Get(index);
}
inline ::structDefinitions::Point3D* Point3DSet::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:structDefinitions.Point3DSet.points)
  return points_.Mutable(index);
}
inline ::structDefinitions::Point3D* Point3DSet::add_points() {
  // @@protoc_insertion_point(field_add:structDefinitions.Point3DSet.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point3D >*
Point3DSet::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:structDefinitions.Point3DSet.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Point3D >&
Point3DSet::points() const {
  // @@protoc_insertion_point(field_list:structDefinitions.Point3DSet.points)
  return points_;
}

// -------------------------------------------------------------------

// Vertex

// required .structDefinitions.Point3D point = 1;
inline bool Vertex::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vertex::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vertex::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vertex::clear_point() {
  if (point_ != NULL) point_->::structDefinitions::Point3D::Clear();
  clear_has_point();
}
inline const ::structDefinitions::Point3D& Vertex::point() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Vertex.point)
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::structDefinitions::Point3D* Vertex::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Vertex.point)
  return point_;
}
inline ::structDefinitions::Point3D* Vertex::release_point() {
  // @@protoc_insertion_point(field_release:structDefinitions.Vertex.point)
  clear_has_point();
  ::structDefinitions::Point3D* temp = point_;
  point_ = NULL;
  return temp;
}
inline void Vertex::set_allocated_point(::structDefinitions::Point3D* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Vertex.point)
}

// required double number = 2;
inline bool Vertex::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vertex::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vertex::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vertex::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline double Vertex::number() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Vertex.number)
  return number_;
}
inline void Vertex::set_number(double value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.Vertex.number)
}

// optional .structDefinitions.Properties prop = 3;
inline bool Vertex::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vertex::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vertex::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vertex::clear_prop() {
  if (prop_ != NULL) prop_->::structDefinitions::Properties::Clear();
  clear_has_prop();
}
inline const ::structDefinitions::Properties& Vertex::prop() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Vertex.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::structDefinitions::Properties* Vertex::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::structDefinitions::Properties;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Vertex.prop)
  return prop_;
}
inline ::structDefinitions::Properties* Vertex::release_prop() {
  // @@protoc_insertion_point(field_release:structDefinitions.Vertex.prop)
  clear_has_prop();
  ::structDefinitions::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Vertex::set_allocated_prop(::structDefinitions::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Vertex.prop)
}

// -------------------------------------------------------------------

// VertexSet

// repeated .structDefinitions.Vertex vertexes = 1;
inline int VertexSet::vertexes_size() const {
  return vertexes_.size();
}
inline void VertexSet::clear_vertexes() {
  vertexes_.Clear();
}
inline const ::structDefinitions::Vertex& VertexSet::vertexes(int index) const {
  // @@protoc_insertion_point(field_get:structDefinitions.VertexSet.vertexes)
  return vertexes_.Get(index);
}
inline ::structDefinitions::Vertex* VertexSet::mutable_vertexes(int index) {
  // @@protoc_insertion_point(field_mutable:structDefinitions.VertexSet.vertexes)
  return vertexes_.Mutable(index);
}
inline ::structDefinitions::Vertex* VertexSet::add_vertexes() {
  // @@protoc_insertion_point(field_add:structDefinitions.VertexSet.vertexes)
  return vertexes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::structDefinitions::Vertex >*
VertexSet::mutable_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:structDefinitions.VertexSet.vertexes)
  return &vertexes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Vertex >&
VertexSet::vertexes() const {
  // @@protoc_insertion_point(field_list:structDefinitions.VertexSet.vertexes)
  return vertexes_;
}

// -------------------------------------------------------------------

// Edge

// required .structDefinitions.Point3D v1 = 1;
inline bool Edge::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_v1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_v1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_v1() {
  if (v1_ != NULL) v1_->::structDefinitions::Point3D::Clear();
  clear_has_v1();
}
inline const ::structDefinitions::Point3D& Edge::v1() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Edge.v1)
  return v1_ != NULL ? *v1_ : *default_instance_->v1_;
}
inline ::structDefinitions::Point3D* Edge::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Edge.v1)
  return v1_;
}
inline ::structDefinitions::Point3D* Edge::release_v1() {
  // @@protoc_insertion_point(field_release:structDefinitions.Edge.v1)
  clear_has_v1();
  ::structDefinitions::Point3D* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline void Edge::set_allocated_v1(::structDefinitions::Point3D* v1) {
  delete v1_;
  v1_ = v1;
  if (v1) {
    set_has_v1();
  } else {
    clear_has_v1();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Edge.v1)
}

// required .structDefinitions.Point3D v2 = 2;
inline bool Edge::has_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_v2() {
  if (v2_ != NULL) v2_->::structDefinitions::Point3D::Clear();
  clear_has_v2();
}
inline const ::structDefinitions::Point3D& Edge::v2() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Edge.v2)
  return v2_ != NULL ? *v2_ : *default_instance_->v2_;
}
inline ::structDefinitions::Point3D* Edge::mutable_v2() {
  set_has_v2();
  if (v2_ == NULL) {
    v2_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Edge.v2)
  return v2_;
}
inline ::structDefinitions::Point3D* Edge::release_v2() {
  // @@protoc_insertion_point(field_release:structDefinitions.Edge.v2)
  clear_has_v2();
  ::structDefinitions::Point3D* temp = v2_;
  v2_ = NULL;
  return temp;
}
inline void Edge::set_allocated_v2(::structDefinitions::Point3D* v2) {
  delete v2_;
  v2_ = v2;
  if (v2) {
    set_has_v2();
  } else {
    clear_has_v2();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Edge.v2)
}

// optional .structDefinitions.Properties prop = 3;
inline bool Edge::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_prop() {
  if (prop_ != NULL) prop_->::structDefinitions::Properties::Clear();
  clear_has_prop();
}
inline const ::structDefinitions::Properties& Edge::prop() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Edge.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::structDefinitions::Properties* Edge::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::structDefinitions::Properties;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Edge.prop)
  return prop_;
}
inline ::structDefinitions::Properties* Edge::release_prop() {
  // @@protoc_insertion_point(field_release:structDefinitions.Edge.prop)
  clear_has_prop();
  ::structDefinitions::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Edge::set_allocated_prop(::structDefinitions::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Edge.prop)
}

// -------------------------------------------------------------------

// EdgeSet

// repeated .structDefinitions.Edge edges = 1;
inline int EdgeSet::edges_size() const {
  return edges_.size();
}
inline void EdgeSet::clear_edges() {
  edges_.Clear();
}
inline const ::structDefinitions::Edge& EdgeSet::edges(int index) const {
  // @@protoc_insertion_point(field_get:structDefinitions.EdgeSet.edges)
  return edges_.Get(index);
}
inline ::structDefinitions::Edge* EdgeSet::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:structDefinitions.EdgeSet.edges)
  return edges_.Mutable(index);
}
inline ::structDefinitions::Edge* EdgeSet::add_edges() {
  // @@protoc_insertion_point(field_add:structDefinitions.EdgeSet.edges)
  return edges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::structDefinitions::Edge >*
EdgeSet::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:structDefinitions.EdgeSet.edges)
  return &edges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Edge >&
EdgeSet::edges() const {
  // @@protoc_insertion_point(field_list:structDefinitions.EdgeSet.edges)
  return edges_;
}

// -------------------------------------------------------------------

// TriangleFace

// required .structDefinitions.Point3D v1 = 1;
inline bool TriangleFace::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriangleFace::set_has_v1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriangleFace::clear_has_v1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriangleFace::clear_v1() {
  if (v1_ != NULL) v1_->::structDefinitions::Point3D::Clear();
  clear_has_v1();
}
inline const ::structDefinitions::Point3D& TriangleFace::v1() const {
  // @@protoc_insertion_point(field_get:structDefinitions.TriangleFace.v1)
  return v1_ != NULL ? *v1_ : *default_instance_->v1_;
}
inline ::structDefinitions::Point3D* TriangleFace::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.TriangleFace.v1)
  return v1_;
}
inline ::structDefinitions::Point3D* TriangleFace::release_v1() {
  // @@protoc_insertion_point(field_release:structDefinitions.TriangleFace.v1)
  clear_has_v1();
  ::structDefinitions::Point3D* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_v1(::structDefinitions::Point3D* v1) {
  delete v1_;
  v1_ = v1;
  if (v1) {
    set_has_v1();
  } else {
    clear_has_v1();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.TriangleFace.v1)
}

// required .structDefinitions.Point3D v2 = 2;
inline bool TriangleFace::has_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriangleFace::set_has_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriangleFace::clear_has_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriangleFace::clear_v2() {
  if (v2_ != NULL) v2_->::structDefinitions::Point3D::Clear();
  clear_has_v2();
}
inline const ::structDefinitions::Point3D& TriangleFace::v2() const {
  // @@protoc_insertion_point(field_get:structDefinitions.TriangleFace.v2)
  return v2_ != NULL ? *v2_ : *default_instance_->v2_;
}
inline ::structDefinitions::Point3D* TriangleFace::mutable_v2() {
  set_has_v2();
  if (v2_ == NULL) {
    v2_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.TriangleFace.v2)
  return v2_;
}
inline ::structDefinitions::Point3D* TriangleFace::release_v2() {
  // @@protoc_insertion_point(field_release:structDefinitions.TriangleFace.v2)
  clear_has_v2();
  ::structDefinitions::Point3D* temp = v2_;
  v2_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_v2(::structDefinitions::Point3D* v2) {
  delete v2_;
  v2_ = v2;
  if (v2) {
    set_has_v2();
  } else {
    clear_has_v2();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.TriangleFace.v2)
}

// required .structDefinitions.Point3D v3 = 3;
inline bool TriangleFace::has_v3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriangleFace::set_has_v3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriangleFace::clear_has_v3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriangleFace::clear_v3() {
  if (v3_ != NULL) v3_->::structDefinitions::Point3D::Clear();
  clear_has_v3();
}
inline const ::structDefinitions::Point3D& TriangleFace::v3() const {
  // @@protoc_insertion_point(field_get:structDefinitions.TriangleFace.v3)
  return v3_ != NULL ? *v3_ : *default_instance_->v3_;
}
inline ::structDefinitions::Point3D* TriangleFace::mutable_v3() {
  set_has_v3();
  if (v3_ == NULL) {
    v3_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.TriangleFace.v3)
  return v3_;
}
inline ::structDefinitions::Point3D* TriangleFace::release_v3() {
  // @@protoc_insertion_point(field_release:structDefinitions.TriangleFace.v3)
  clear_has_v3();
  ::structDefinitions::Point3D* temp = v3_;
  v3_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_v3(::structDefinitions::Point3D* v3) {
  delete v3_;
  v3_ = v3;
  if (v3) {
    set_has_v3();
  } else {
    clear_has_v3();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.TriangleFace.v3)
}

// optional .structDefinitions.Properties prop = 4;
inline bool TriangleFace::has_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TriangleFace::set_has_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TriangleFace::clear_has_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TriangleFace::clear_prop() {
  if (prop_ != NULL) prop_->::structDefinitions::Properties::Clear();
  clear_has_prop();
}
inline const ::structDefinitions::Properties& TriangleFace::prop() const {
  // @@protoc_insertion_point(field_get:structDefinitions.TriangleFace.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::structDefinitions::Properties* TriangleFace::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::structDefinitions::Properties;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.TriangleFace.prop)
  return prop_;
}
inline ::structDefinitions::Properties* TriangleFace::release_prop() {
  // @@protoc_insertion_point(field_release:structDefinitions.TriangleFace.prop)
  clear_has_prop();
  ::structDefinitions::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_prop(::structDefinitions::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.TriangleFace.prop)
}

// -------------------------------------------------------------------

// TriangleFaceSet

// repeated .structDefinitions.TriangleFace triangleFaces = 1;
inline int TriangleFaceSet::trianglefaces_size() const {
  return trianglefaces_.size();
}
inline void TriangleFaceSet::clear_trianglefaces() {
  trianglefaces_.Clear();
}
inline const ::structDefinitions::TriangleFace& TriangleFaceSet::trianglefaces(int index) const {
  // @@protoc_insertion_point(field_get:structDefinitions.TriangleFaceSet.triangleFaces)
  return trianglefaces_.Get(index);
}
inline ::structDefinitions::TriangleFace* TriangleFaceSet::mutable_trianglefaces(int index) {
  // @@protoc_insertion_point(field_mutable:structDefinitions.TriangleFaceSet.triangleFaces)
  return trianglefaces_.Mutable(index);
}
inline ::structDefinitions::TriangleFace* TriangleFaceSet::add_trianglefaces() {
  // @@protoc_insertion_point(field_add:structDefinitions.TriangleFaceSet.triangleFaces)
  return trianglefaces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::structDefinitions::TriangleFace >*
TriangleFaceSet::mutable_trianglefaces() {
  // @@protoc_insertion_point(field_mutable_list:structDefinitions.TriangleFaceSet.triangleFaces)
  return &trianglefaces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::structDefinitions::TriangleFace >&
TriangleFaceSet::trianglefaces() const {
  // @@protoc_insertion_point(field_list:structDefinitions.TriangleFaceSet.triangleFaces)
  return trianglefaces_;
}

// -------------------------------------------------------------------

// Block

// required .structDefinitions.Point3D v1 = 1;
inline bool Block::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_v1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_v1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_v1() {
  if (v1_ != NULL) v1_->::structDefinitions::Point3D::Clear();
  clear_has_v1();
}
inline const ::structDefinitions::Point3D& Block::v1() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Block.v1)
  return v1_ != NULL ? *v1_ : *default_instance_->v1_;
}
inline ::structDefinitions::Point3D* Block::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Block.v1)
  return v1_;
}
inline ::structDefinitions::Point3D* Block::release_v1() {
  // @@protoc_insertion_point(field_release:structDefinitions.Block.v1)
  clear_has_v1();
  ::structDefinitions::Point3D* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline void Block::set_allocated_v1(::structDefinitions::Point3D* v1) {
  delete v1_;
  v1_ = v1;
  if (v1) {
    set_has_v1();
  } else {
    clear_has_v1();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Block.v1)
}

// required .structDefinitions.Point3D v2 = 2;
inline bool Block::has_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_v2() {
  if (v2_ != NULL) v2_->::structDefinitions::Point3D::Clear();
  clear_has_v2();
}
inline const ::structDefinitions::Point3D& Block::v2() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Block.v2)
  return v2_ != NULL ? *v2_ : *default_instance_->v2_;
}
inline ::structDefinitions::Point3D* Block::mutable_v2() {
  set_has_v2();
  if (v2_ == NULL) {
    v2_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Block.v2)
  return v2_;
}
inline ::structDefinitions::Point3D* Block::release_v2() {
  // @@protoc_insertion_point(field_release:structDefinitions.Block.v2)
  clear_has_v2();
  ::structDefinitions::Point3D* temp = v2_;
  v2_ = NULL;
  return temp;
}
inline void Block::set_allocated_v2(::structDefinitions::Point3D* v2) {
  delete v2_;
  v2_ = v2;
  if (v2) {
    set_has_v2();
  } else {
    clear_has_v2();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Block.v2)
}

// required .structDefinitions.Point3D v3 = 3;
inline bool Block::has_v3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_v3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_v3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_v3() {
  if (v3_ != NULL) v3_->::structDefinitions::Point3D::Clear();
  clear_has_v3();
}
inline const ::structDefinitions::Point3D& Block::v3() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Block.v3)
  return v3_ != NULL ? *v3_ : *default_instance_->v3_;
}
inline ::structDefinitions::Point3D* Block::mutable_v3() {
  set_has_v3();
  if (v3_ == NULL) {
    v3_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Block.v3)
  return v3_;
}
inline ::structDefinitions::Point3D* Block::release_v3() {
  // @@protoc_insertion_point(field_release:structDefinitions.Block.v3)
  clear_has_v3();
  ::structDefinitions::Point3D* temp = v3_;
  v3_ = NULL;
  return temp;
}
inline void Block::set_allocated_v3(::structDefinitions::Point3D* v3) {
  delete v3_;
  v3_ = v3;
  if (v3) {
    set_has_v3();
  } else {
    clear_has_v3();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Block.v3)
}

// required .structDefinitions.Point3D v4 = 4;
inline bool Block::has_v4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_v4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_v4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_v4() {
  if (v4_ != NULL) v4_->::structDefinitions::Point3D::Clear();
  clear_has_v4();
}
inline const ::structDefinitions::Point3D& Block::v4() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Block.v4)
  return v4_ != NULL ? *v4_ : *default_instance_->v4_;
}
inline ::structDefinitions::Point3D* Block::mutable_v4() {
  set_has_v4();
  if (v4_ == NULL) {
    v4_ = new ::structDefinitions::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Block.v4)
  return v4_;
}
inline ::structDefinitions::Point3D* Block::release_v4() {
  // @@protoc_insertion_point(field_release:structDefinitions.Block.v4)
  clear_has_v4();
  ::structDefinitions::Point3D* temp = v4_;
  v4_ = NULL;
  return temp;
}
inline void Block::set_allocated_v4(::structDefinitions::Point3D* v4) {
  delete v4_;
  v4_ = v4;
  if (v4) {
    set_has_v4();
  } else {
    clear_has_v4();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Block.v4)
}

// optional .structDefinitions.Properties prop = 5;
inline bool Block::has_prop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Block::set_has_prop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Block::clear_has_prop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Block::clear_prop() {
  if (prop_ != NULL) prop_->::structDefinitions::Properties::Clear();
  clear_has_prop();
}
inline const ::structDefinitions::Properties& Block::prop() const {
  // @@protoc_insertion_point(field_get:structDefinitions.Block.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::structDefinitions::Properties* Block::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::structDefinitions::Properties;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.Block.prop)
  return prop_;
}
inline ::structDefinitions::Properties* Block::release_prop() {
  // @@protoc_insertion_point(field_release:structDefinitions.Block.prop)
  clear_has_prop();
  ::structDefinitions::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Block::set_allocated_prop(::structDefinitions::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.Block.prop)
}

// -------------------------------------------------------------------

// BlockSet

// repeated .structDefinitions.Block blocks = 1;
inline int BlockSet::blocks_size() const {
  return blocks_.size();
}
inline void BlockSet::clear_blocks() {
  blocks_.Clear();
}
inline const ::structDefinitions::Block& BlockSet::blocks(int index) const {
  // @@protoc_insertion_point(field_get:structDefinitions.BlockSet.blocks)
  return blocks_.Get(index);
}
inline ::structDefinitions::Block* BlockSet::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:structDefinitions.BlockSet.blocks)
  return blocks_.Mutable(index);
}
inline ::structDefinitions::Block* BlockSet::add_blocks() {
  // @@protoc_insertion_point(field_add:structDefinitions.BlockSet.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::structDefinitions::Block >*
BlockSet::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:structDefinitions.BlockSet.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::structDefinitions::Block >&
BlockSet::blocks() const {
  // @@protoc_insertion_point(field_list:structDefinitions.BlockSet.blocks)
  return blocks_;
}

// -------------------------------------------------------------------

// MessageInfo

// required .structDefinitions.MessageInfo.Type type = 1;
inline bool MessageInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::structDefinitions::MessageInfo_Type MessageInfo::type() const {
  // @@protoc_insertion_point(field_get:structDefinitions.MessageInfo.type)
  return static_cast< ::structDefinitions::MessageInfo_Type >(type_);
}
inline void MessageInfo::set_type(::structDefinitions::MessageInfo_Type value) {
  assert(::structDefinitions::MessageInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.MessageInfo.type)
}

// -------------------------------------------------------------------

// DataPackage

// optional .structDefinitions.Point2DSet points2D = 1;
inline bool DataPackage::has_points2d() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataPackage::set_has_points2d() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataPackage::clear_has_points2d() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataPackage::clear_points2d() {
  if (points2d_ != NULL) points2d_->::structDefinitions::Point2DSet::Clear();
  clear_has_points2d();
}
inline const ::structDefinitions::Point2DSet& DataPackage::points2d() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.points2D)
  return points2d_ != NULL ? *points2d_ : *default_instance_->points2d_;
}
inline ::structDefinitions::Point2DSet* DataPackage::mutable_points2d() {
  set_has_points2d();
  if (points2d_ == NULL) {
    points2d_ = new ::structDefinitions::Point2DSet;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.DataPackage.points2D)
  return points2d_;
}
inline ::structDefinitions::Point2DSet* DataPackage::release_points2d() {
  // @@protoc_insertion_point(field_release:structDefinitions.DataPackage.points2D)
  clear_has_points2d();
  ::structDefinitions::Point2DSet* temp = points2d_;
  points2d_ = NULL;
  return temp;
}
inline void DataPackage::set_allocated_points2d(::structDefinitions::Point2DSet* points2d) {
  delete points2d_;
  points2d_ = points2d;
  if (points2d) {
    set_has_points2d();
  } else {
    clear_has_points2d();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.DataPackage.points2D)
}

// optional .structDefinitions.Point3DSet points3D = 2;
inline bool DataPackage::has_points3d() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataPackage::set_has_points3d() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataPackage::clear_has_points3d() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataPackage::clear_points3d() {
  if (points3d_ != NULL) points3d_->::structDefinitions::Point3DSet::Clear();
  clear_has_points3d();
}
inline const ::structDefinitions::Point3DSet& DataPackage::points3d() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.points3D)
  return points3d_ != NULL ? *points3d_ : *default_instance_->points3d_;
}
inline ::structDefinitions::Point3DSet* DataPackage::mutable_points3d() {
  set_has_points3d();
  if (points3d_ == NULL) {
    points3d_ = new ::structDefinitions::Point3DSet;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.DataPackage.points3D)
  return points3d_;
}
inline ::structDefinitions::Point3DSet* DataPackage::release_points3d() {
  // @@protoc_insertion_point(field_release:structDefinitions.DataPackage.points3D)
  clear_has_points3d();
  ::structDefinitions::Point3DSet* temp = points3d_;
  points3d_ = NULL;
  return temp;
}
inline void DataPackage::set_allocated_points3d(::structDefinitions::Point3DSet* points3d) {
  delete points3d_;
  points3d_ = points3d;
  if (points3d) {
    set_has_points3d();
  } else {
    clear_has_points3d();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.DataPackage.points3D)
}

// optional .structDefinitions.VertexSet vertexes = 3;
inline bool DataPackage::has_vertexes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataPackage::set_has_vertexes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataPackage::clear_has_vertexes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataPackage::clear_vertexes() {
  if (vertexes_ != NULL) vertexes_->::structDefinitions::VertexSet::Clear();
  clear_has_vertexes();
}
inline const ::structDefinitions::VertexSet& DataPackage::vertexes() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.vertexes)
  return vertexes_ != NULL ? *vertexes_ : *default_instance_->vertexes_;
}
inline ::structDefinitions::VertexSet* DataPackage::mutable_vertexes() {
  set_has_vertexes();
  if (vertexes_ == NULL) {
    vertexes_ = new ::structDefinitions::VertexSet;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.DataPackage.vertexes)
  return vertexes_;
}
inline ::structDefinitions::VertexSet* DataPackage::release_vertexes() {
  // @@protoc_insertion_point(field_release:structDefinitions.DataPackage.vertexes)
  clear_has_vertexes();
  ::structDefinitions::VertexSet* temp = vertexes_;
  vertexes_ = NULL;
  return temp;
}
inline void DataPackage::set_allocated_vertexes(::structDefinitions::VertexSet* vertexes) {
  delete vertexes_;
  vertexes_ = vertexes;
  if (vertexes) {
    set_has_vertexes();
  } else {
    clear_has_vertexes();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.DataPackage.vertexes)
}

// optional .structDefinitions.EdgeSet edges = 4;
inline bool DataPackage::has_edges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataPackage::set_has_edges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataPackage::clear_has_edges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataPackage::clear_edges() {
  if (edges_ != NULL) edges_->::structDefinitions::EdgeSet::Clear();
  clear_has_edges();
}
inline const ::structDefinitions::EdgeSet& DataPackage::edges() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.edges)
  return edges_ != NULL ? *edges_ : *default_instance_->edges_;
}
inline ::structDefinitions::EdgeSet* DataPackage::mutable_edges() {
  set_has_edges();
  if (edges_ == NULL) {
    edges_ = new ::structDefinitions::EdgeSet;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.DataPackage.edges)
  return edges_;
}
inline ::structDefinitions::EdgeSet* DataPackage::release_edges() {
  // @@protoc_insertion_point(field_release:structDefinitions.DataPackage.edges)
  clear_has_edges();
  ::structDefinitions::EdgeSet* temp = edges_;
  edges_ = NULL;
  return temp;
}
inline void DataPackage::set_allocated_edges(::structDefinitions::EdgeSet* edges) {
  delete edges_;
  edges_ = edges;
  if (edges) {
    set_has_edges();
  } else {
    clear_has_edges();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.DataPackage.edges)
}

// optional .structDefinitions.TriangleFaceSet faces = 5;
inline bool DataPackage::has_faces() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataPackage::set_has_faces() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataPackage::clear_has_faces() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataPackage::clear_faces() {
  if (faces_ != NULL) faces_->::structDefinitions::TriangleFaceSet::Clear();
  clear_has_faces();
}
inline const ::structDefinitions::TriangleFaceSet& DataPackage::faces() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.faces)
  return faces_ != NULL ? *faces_ : *default_instance_->faces_;
}
inline ::structDefinitions::TriangleFaceSet* DataPackage::mutable_faces() {
  set_has_faces();
  if (faces_ == NULL) {
    faces_ = new ::structDefinitions::TriangleFaceSet;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.DataPackage.faces)
  return faces_;
}
inline ::structDefinitions::TriangleFaceSet* DataPackage::release_faces() {
  // @@protoc_insertion_point(field_release:structDefinitions.DataPackage.faces)
  clear_has_faces();
  ::structDefinitions::TriangleFaceSet* temp = faces_;
  faces_ = NULL;
  return temp;
}
inline void DataPackage::set_allocated_faces(::structDefinitions::TriangleFaceSet* faces) {
  delete faces_;
  faces_ = faces;
  if (faces) {
    set_has_faces();
  } else {
    clear_has_faces();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.DataPackage.faces)
}

// optional .structDefinitions.BlockSet blocks = 6;
inline bool DataPackage::has_blocks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataPackage::set_has_blocks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataPackage::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataPackage::clear_blocks() {
  if (blocks_ != NULL) blocks_->::structDefinitions::BlockSet::Clear();
  clear_has_blocks();
}
inline const ::structDefinitions::BlockSet& DataPackage::blocks() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.blocks)
  return blocks_ != NULL ? *blocks_ : *default_instance_->blocks_;
}
inline ::structDefinitions::BlockSet* DataPackage::mutable_blocks() {
  set_has_blocks();
  if (blocks_ == NULL) {
    blocks_ = new ::structDefinitions::BlockSet;
  }
  // @@protoc_insertion_point(field_mutable:structDefinitions.DataPackage.blocks)
  return blocks_;
}
inline ::structDefinitions::BlockSet* DataPackage::release_blocks() {
  // @@protoc_insertion_point(field_release:structDefinitions.DataPackage.blocks)
  clear_has_blocks();
  ::structDefinitions::BlockSet* temp = blocks_;
  blocks_ = NULL;
  return temp;
}
inline void DataPackage::set_allocated_blocks(::structDefinitions::BlockSet* blocks) {
  delete blocks_;
  blocks_ = blocks;
  if (blocks) {
    set_has_blocks();
  } else {
    clear_has_blocks();
  }
  // @@protoc_insertion_point(field_set_allocated:structDefinitions.DataPackage.blocks)
}

// required bool endOfData = 7;
inline bool DataPackage::has_endofdata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataPackage::set_has_endofdata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataPackage::clear_has_endofdata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataPackage::clear_endofdata() {
  endofdata_ = false;
  clear_has_endofdata();
}
inline bool DataPackage::endofdata() const {
  // @@protoc_insertion_point(field_get:structDefinitions.DataPackage.endOfData)
  return endofdata_;
}
inline void DataPackage::set_endofdata(bool value) {
  set_has_endofdata();
  endofdata_ = value;
  // @@protoc_insertion_point(field_set:structDefinitions.DataPackage.endOfData)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace structDefinitions

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::structDefinitions::MessageInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::structDefinitions::MessageInfo_Type>() {
  return ::structDefinitions::MessageInfo_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structs_2eproto__INCLUDED
