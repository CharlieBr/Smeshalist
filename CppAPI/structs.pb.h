// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structs.proto

#ifndef PROTOBUF_structs_2eproto__INCLUDED
#define PROTOBUF_structs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_structs_2eproto();
void protobuf_AssignDesc_structs_2eproto();
void protobuf_ShutdownFile_structs_2eproto();

class Block;
class DataPackage;
class Edge;
class Header;
class MessageInfo;
class Point2D;
class Point3D;
class Properties;
class TriangleFace;
class Vertex;

enum MessageInfo_Type {
  MessageInfo_Type_DATA = 1,
  MessageInfo_Type_RENDER = 2,
  MessageInfo_Type_BREAKPOINT = 3,
  MessageInfo_Type_ACCEPTED = 4,
  MessageInfo_Type_REJECTED = 5,
  MessageInfo_Type_ACK = 6
};
bool MessageInfo_Type_IsValid(int value);
const MessageInfo_Type MessageInfo_Type_Type_MIN = MessageInfo_Type_DATA;
const MessageInfo_Type MessageInfo_Type_Type_MAX = MessageInfo_Type_ACK;
const int MessageInfo_Type_Type_ARRAYSIZE = MessageInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageInfo_Type_descriptor();
inline const ::std::string& MessageInfo_Type_Name(MessageInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageInfo_Type_descriptor(), value);
}
inline bool MessageInfo_Type_Parse(
    const ::std::string& name, MessageInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageInfo_Type>(
    MessageInfo_Type_descriptor(), name, value);
}
// ===================================================================

class Properties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Properties) */ {
 public:
  Properties();
  virtual ~Properties();

  Properties(const Properties& from);

  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties& default_instance();

  void Swap(Properties* other);

  // implements Message ----------------------------------------------

  inline Properties* New() const { return New(NULL); }

  Properties* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties& from);
  void MergeFrom(const Properties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Properties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double quality = 1;
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 1;
  double quality() const;
  void set_quality(double value);

  // optional string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional int32 groupId = 3;
  bool has_groupid() const;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 3;
  ::google::protobuf::int32 groupid() const;
  void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Properties)
 private:
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double quality_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::int32 groupid_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Properties* default_instance_;
};
// -------------------------------------------------------------------

class Point2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Point2D) */ {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2D& default_instance();

  void Swap(Point2D* other);

  // implements Message ----------------------------------------------

  inline Point2D* New() const { return New(NULL); }

  Point2D* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional .Properties prop = 3;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 3;
  const ::Properties& prop() const;
  ::Properties* mutable_prop();
  ::Properties* release_prop();
  void set_allocated_prop(::Properties* prop);

  // @@protoc_insertion_point(class_scope:Point2D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  ::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Point2D* default_instance_;
};
// -------------------------------------------------------------------

class Point3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Point3D) */ {
 public:
  Point3D();
  virtual ~Point3D();

  Point3D(const Point3D& from);

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3D& default_instance();

  void Swap(Point3D* other);

  // implements Message ----------------------------------------------

  inline Point3D* New() const { return New(NULL); }

  Point3D* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point3D& from);
  void MergeFrom(const Point3D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional .Properties prop = 4;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 4;
  const ::Properties& prop() const;
  ::Properties* mutable_prop();
  ::Properties* release_prop();
  void set_allocated_prop(::Properties* prop);

  // @@protoc_insertion_point(class_scope:Point3D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  ::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Point3D* default_instance_;
};
// -------------------------------------------------------------------

class Vertex : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vertex) */ {
 public:
  Vertex();
  virtual ~Vertex();

  Vertex(const Vertex& from);

  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex& default_instance();

  void Swap(Vertex* other);

  // implements Message ----------------------------------------------

  inline Vertex* New() const { return New(NULL); }

  Vertex* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vertex& from);
  void MergeFrom(const Vertex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vertex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Point3D point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::Point3D& point() const;
  ::Point3D* mutable_point();
  ::Point3D* release_point();
  void set_allocated_point(::Point3D* point);

  // required double number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  double number() const;
  void set_number(double value);

  // optional .Properties prop = 3;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 3;
  const ::Properties& prop() const;
  ::Properties* mutable_prop();
  ::Properties* release_prop();
  void set_allocated_prop(::Properties* prop);

  // @@protoc_insertion_point(class_scope:Vertex)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Point3D* point_;
  double number_;
  ::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Vertex* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  inline Edge* New() const { return New(NULL); }

  Edge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Point3D v1 = 1;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  const ::Point3D& v1() const;
  ::Point3D* mutable_v1();
  ::Point3D* release_v1();
  void set_allocated_v1(::Point3D* v1);

  // required .Point3D v2 = 2;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  const ::Point3D& v2() const;
  ::Point3D* mutable_v2();
  ::Point3D* release_v2();
  void set_allocated_v2(::Point3D* v2);

  // optional .Properties prop = 3;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 3;
  const ::Properties& prop() const;
  ::Properties* mutable_prop();
  ::Properties* release_prop();
  void set_allocated_prop(::Properties* prop);

  // @@protoc_insertion_point(class_scope:Edge)
 private:
  inline void set_has_v1();
  inline void clear_has_v1();
  inline void set_has_v2();
  inline void clear_has_v2();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Point3D* v1_;
  ::Point3D* v2_;
  ::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class TriangleFace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TriangleFace) */ {
 public:
  TriangleFace();
  virtual ~TriangleFace();

  TriangleFace(const TriangleFace& from);

  inline TriangleFace& operator=(const TriangleFace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriangleFace& default_instance();

  void Swap(TriangleFace* other);

  // implements Message ----------------------------------------------

  inline TriangleFace* New() const { return New(NULL); }

  TriangleFace* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriangleFace& from);
  void MergeFrom(const TriangleFace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriangleFace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Point3D v1 = 1;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  const ::Point3D& v1() const;
  ::Point3D* mutable_v1();
  ::Point3D* release_v1();
  void set_allocated_v1(::Point3D* v1);

  // required .Point3D v2 = 2;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  const ::Point3D& v2() const;
  ::Point3D* mutable_v2();
  ::Point3D* release_v2();
  void set_allocated_v2(::Point3D* v2);

  // required .Point3D v3 = 3;
  bool has_v3() const;
  void clear_v3();
  static const int kV3FieldNumber = 3;
  const ::Point3D& v3() const;
  ::Point3D* mutable_v3();
  ::Point3D* release_v3();
  void set_allocated_v3(::Point3D* v3);

  // optional .Properties prop = 4;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 4;
  const ::Properties& prop() const;
  ::Properties* mutable_prop();
  ::Properties* release_prop();
  void set_allocated_prop(::Properties* prop);

  // @@protoc_insertion_point(class_scope:TriangleFace)
 private:
  inline void set_has_v1();
  inline void clear_has_v1();
  inline void set_has_v2();
  inline void clear_has_v2();
  inline void set_has_v3();
  inline void clear_has_v3();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Point3D* v1_;
  ::Point3D* v2_;
  ::Point3D* v3_;
  ::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static TriangleFace* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Point3D v1 = 1;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  const ::Point3D& v1() const;
  ::Point3D* mutable_v1();
  ::Point3D* release_v1();
  void set_allocated_v1(::Point3D* v1);

  // required .Point3D v2 = 2;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  const ::Point3D& v2() const;
  ::Point3D* mutable_v2();
  ::Point3D* release_v2();
  void set_allocated_v2(::Point3D* v2);

  // required .Point3D v3 = 3;
  bool has_v3() const;
  void clear_v3();
  static const int kV3FieldNumber = 3;
  const ::Point3D& v3() const;
  ::Point3D* mutable_v3();
  ::Point3D* release_v3();
  void set_allocated_v3(::Point3D* v3);

  // required .Point3D v4 = 4;
  bool has_v4() const;
  void clear_v4();
  static const int kV4FieldNumber = 4;
  const ::Point3D& v4() const;
  ::Point3D* mutable_v4();
  ::Point3D* release_v4();
  void set_allocated_v4(::Point3D* v4);

  // optional .Properties prop = 5;
  bool has_prop() const;
  void clear_prop();
  static const int kPropFieldNumber = 5;
  const ::Properties& prop() const;
  ::Properties* mutable_prop();
  ::Properties* release_prop();
  void set_allocated_prop(::Properties* prop);

  // @@protoc_insertion_point(class_scope:Block)
 private:
  inline void set_has_v1();
  inline void clear_has_v1();
  inline void set_has_v2();
  inline void clear_has_v2();
  inline void set_has_v3();
  inline void clear_has_v3();
  inline void set_has_v4();
  inline void clear_has_v4();
  inline void set_has_prop();
  inline void clear_has_prop();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Point3D* v1_;
  ::Point3D* v2_;
  ::Point3D* v3_;
  ::Point3D* v4_;
  ::Properties* prop_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class MessageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageInfo) */ {
 public:
  MessageInfo();
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageInfo& default_instance();

  void Swap(MessageInfo* other);

  // implements Message ----------------------------------------------

  inline MessageInfo* New() const { return New(NULL); }

  MessageInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageInfo_Type Type;
  static const Type DATA =
    MessageInfo_Type_DATA;
  static const Type RENDER =
    MessageInfo_Type_RENDER;
  static const Type BREAKPOINT =
    MessageInfo_Type_BREAKPOINT;
  static const Type ACCEPTED =
    MessageInfo_Type_ACCEPTED;
  static const Type REJECTED =
    MessageInfo_Type_REJECTED;
  static const Type ACK =
    MessageInfo_Type_ACK;
  static inline bool Type_IsValid(int value) {
    return MessageInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MessageInfo_Type_Type_MIN;
  static const Type Type_MAX =
    MessageInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MessageInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MessageInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MessageInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MessageInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MessageInfo.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::MessageInfo_Type type() const;
  void set_type(::MessageInfo_Type value);

  // @@protoc_insertion_point(class_scope:MessageInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static MessageInfo* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sizeOfData = 1;
  bool has_sizeofdata() const;
  void clear_sizeofdata();
  static const int kSizeOfDataFieldNumber = 1;
  ::google::protobuf::int32 sizeofdata() const;
  void set_sizeofdata(::google::protobuf::int32 value);

  // required bool endOfData = 7;
  bool has_endofdata() const;
  void clear_endofdata();
  static const int kEndOfDataFieldNumber = 7;
  bool endofdata() const;
  void set_endofdata(bool value);

  // @@protoc_insertion_point(class_scope:Header)
 private:
  inline void set_has_sizeofdata();
  inline void clear_has_sizeofdata();
  inline void set_has_endofdata();
  inline void clear_has_endofdata();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sizeofdata_;
  bool endofdata_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class DataPackage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataPackage) */ {
 public:
  DataPackage();
  virtual ~DataPackage();

  DataPackage(const DataPackage& from);

  inline DataPackage& operator=(const DataPackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataPackage& default_instance();

  void Swap(DataPackage* other);

  // implements Message ----------------------------------------------

  inline DataPackage* New() const { return New(NULL); }

  DataPackage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataPackage& from);
  void MergeFrom(const DataPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataPackage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Point2D points2D = 1;
  int points2d_size() const;
  void clear_points2d();
  static const int kPoints2DFieldNumber = 1;
  const ::Point2D& points2d(int index) const;
  ::Point2D* mutable_points2d(int index);
  ::Point2D* add_points2d();
  ::google::protobuf::RepeatedPtrField< ::Point2D >*
      mutable_points2d();
  const ::google::protobuf::RepeatedPtrField< ::Point2D >&
      points2d() const;

  // repeated .Point3D points3D = 2;
  int points3d_size() const;
  void clear_points3d();
  static const int kPoints3DFieldNumber = 2;
  const ::Point3D& points3d(int index) const;
  ::Point3D* mutable_points3d(int index);
  ::Point3D* add_points3d();
  ::google::protobuf::RepeatedPtrField< ::Point3D >*
      mutable_points3d();
  const ::google::protobuf::RepeatedPtrField< ::Point3D >&
      points3d() const;

  // repeated .Vertex vertexes = 3;
  int vertexes_size() const;
  void clear_vertexes();
  static const int kVertexesFieldNumber = 3;
  const ::Vertex& vertexes(int index) const;
  ::Vertex* mutable_vertexes(int index);
  ::Vertex* add_vertexes();
  ::google::protobuf::RepeatedPtrField< ::Vertex >*
      mutable_vertexes();
  const ::google::protobuf::RepeatedPtrField< ::Vertex >&
      vertexes() const;

  // repeated .Edge edges = 4;
  int edges_size() const;
  void clear_edges();
  static const int kEdgesFieldNumber = 4;
  const ::Edge& edges(int index) const;
  ::Edge* mutable_edges(int index);
  ::Edge* add_edges();
  ::google::protobuf::RepeatedPtrField< ::Edge >*
      mutable_edges();
  const ::google::protobuf::RepeatedPtrField< ::Edge >&
      edges() const;

  // repeated .TriangleFace faces = 5;
  int faces_size() const;
  void clear_faces();
  static const int kFacesFieldNumber = 5;
  const ::TriangleFace& faces(int index) const;
  ::TriangleFace* mutable_faces(int index);
  ::TriangleFace* add_faces();
  ::google::protobuf::RepeatedPtrField< ::TriangleFace >*
      mutable_faces();
  const ::google::protobuf::RepeatedPtrField< ::TriangleFace >&
      faces() const;

  // repeated .Block blocks = 6;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 6;
  const ::Block& blocks(int index) const;
  ::Block* mutable_blocks(int index);
  ::Block* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::Block >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::Block >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:DataPackage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Point2D > points2d_;
  ::google::protobuf::RepeatedPtrField< ::Point3D > points3d_;
  ::google::protobuf::RepeatedPtrField< ::Vertex > vertexes_;
  ::google::protobuf::RepeatedPtrField< ::Edge > edges_;
  ::google::protobuf::RepeatedPtrField< ::TriangleFace > faces_;
  ::google::protobuf::RepeatedPtrField< ::Block > blocks_;
  friend void  protobuf_AddDesc_structs_2eproto();
  friend void protobuf_AssignDesc_structs_2eproto();
  friend void protobuf_ShutdownFile_structs_2eproto();

  void InitAsDefaultInstance();
  static DataPackage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Properties

// optional double quality = 1;
inline bool Properties::has_quality() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Properties::set_has_quality() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Properties::clear_has_quality() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Properties::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double Properties::quality() const {
  // @@protoc_insertion_point(field_get:Properties.quality)
  return quality_;
}
inline void Properties::set_quality(double value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:Properties.quality)
}

// optional string label = 2;
inline bool Properties::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Properties::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Properties::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Properties::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& Properties::label() const {
  // @@protoc_insertion_point(field_get:Properties.label)
  return label_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Properties::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Properties.label)
}
inline void Properties::set_label(const char* value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Properties.label)
}
inline void Properties::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Properties.label)
}
inline ::std::string* Properties::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:Properties.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Properties::release_label() {
  // @@protoc_insertion_point(field_release:Properties.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Properties::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Properties.label)
}

// optional int32 groupId = 3;
inline bool Properties::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Properties::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Properties::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Properties::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 Properties::groupid() const {
  // @@protoc_insertion_point(field_get:Properties.groupId)
  return groupid_;
}
inline void Properties::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Properties.groupId)
}

// -------------------------------------------------------------------

// Point2D

// required double x = 1;
inline bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point2D::x() const {
  // @@protoc_insertion_point(field_get:Point2D.x)
  return x_;
}
inline void Point2D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Point2D.x)
}

// required double y = 2;
inline bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point2D::y() const {
  // @@protoc_insertion_point(field_get:Point2D.y)
  return y_;
}
inline void Point2D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Point2D.y)
}

// optional .Properties prop = 3;
inline bool Point2D::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point2D::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point2D::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point2D::clear_prop() {
  if (prop_ != NULL) prop_->::Properties::Clear();
  clear_has_prop();
}
inline const ::Properties& Point2D::prop() const {
  // @@protoc_insertion_point(field_get:Point2D.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::Properties* Point2D::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::Properties;
  }
  // @@protoc_insertion_point(field_mutable:Point2D.prop)
  return prop_;
}
inline ::Properties* Point2D::release_prop() {
  // @@protoc_insertion_point(field_release:Point2D.prop)
  clear_has_prop();
  ::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Point2D::set_allocated_prop(::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Point2D.prop)
}

// -------------------------------------------------------------------

// Point3D

// required double x = 1;
inline bool Point3D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point3D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point3D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:Point3D.x)
  return x_;
}
inline void Point3D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Point3D.x)
}

// required double y = 2;
inline bool Point3D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point3D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point3D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:Point3D.y)
  return y_;
}
inline void Point3D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Point3D.y)
}

// required double z = 3;
inline bool Point3D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point3D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point3D::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:Point3D.z)
  return z_;
}
inline void Point3D::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Point3D.z)
}

// optional .Properties prop = 4;
inline bool Point3D::has_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Point3D::set_has_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Point3D::clear_has_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Point3D::clear_prop() {
  if (prop_ != NULL) prop_->::Properties::Clear();
  clear_has_prop();
}
inline const ::Properties& Point3D::prop() const {
  // @@protoc_insertion_point(field_get:Point3D.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::Properties* Point3D::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::Properties;
  }
  // @@protoc_insertion_point(field_mutable:Point3D.prop)
  return prop_;
}
inline ::Properties* Point3D::release_prop() {
  // @@protoc_insertion_point(field_release:Point3D.prop)
  clear_has_prop();
  ::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Point3D::set_allocated_prop(::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Point3D.prop)
}

// -------------------------------------------------------------------

// Vertex

// required .Point3D point = 1;
inline bool Vertex::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vertex::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vertex::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vertex::clear_point() {
  if (point_ != NULL) point_->::Point3D::Clear();
  clear_has_point();
}
inline const ::Point3D& Vertex::point() const {
  // @@protoc_insertion_point(field_get:Vertex.point)
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::Point3D* Vertex::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Vertex.point)
  return point_;
}
inline ::Point3D* Vertex::release_point() {
  // @@protoc_insertion_point(field_release:Vertex.point)
  clear_has_point();
  ::Point3D* temp = point_;
  point_ = NULL;
  return temp;
}
inline void Vertex::set_allocated_point(::Point3D* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:Vertex.point)
}

// required double number = 2;
inline bool Vertex::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vertex::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vertex::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vertex::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline double Vertex::number() const {
  // @@protoc_insertion_point(field_get:Vertex.number)
  return number_;
}
inline void Vertex::set_number(double value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:Vertex.number)
}

// optional .Properties prop = 3;
inline bool Vertex::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vertex::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vertex::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vertex::clear_prop() {
  if (prop_ != NULL) prop_->::Properties::Clear();
  clear_has_prop();
}
inline const ::Properties& Vertex::prop() const {
  // @@protoc_insertion_point(field_get:Vertex.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::Properties* Vertex::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::Properties;
  }
  // @@protoc_insertion_point(field_mutable:Vertex.prop)
  return prop_;
}
inline ::Properties* Vertex::release_prop() {
  // @@protoc_insertion_point(field_release:Vertex.prop)
  clear_has_prop();
  ::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Vertex::set_allocated_prop(::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Vertex.prop)
}

// -------------------------------------------------------------------

// Edge

// required .Point3D v1 = 1;
inline bool Edge::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_v1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_v1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_v1() {
  if (v1_ != NULL) v1_->::Point3D::Clear();
  clear_has_v1();
}
inline const ::Point3D& Edge::v1() const {
  // @@protoc_insertion_point(field_get:Edge.v1)
  return v1_ != NULL ? *v1_ : *default_instance_->v1_;
}
inline ::Point3D* Edge::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Edge.v1)
  return v1_;
}
inline ::Point3D* Edge::release_v1() {
  // @@protoc_insertion_point(field_release:Edge.v1)
  clear_has_v1();
  ::Point3D* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline void Edge::set_allocated_v1(::Point3D* v1) {
  delete v1_;
  v1_ = v1;
  if (v1) {
    set_has_v1();
  } else {
    clear_has_v1();
  }
  // @@protoc_insertion_point(field_set_allocated:Edge.v1)
}

// required .Point3D v2 = 2;
inline bool Edge::has_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_v2() {
  if (v2_ != NULL) v2_->::Point3D::Clear();
  clear_has_v2();
}
inline const ::Point3D& Edge::v2() const {
  // @@protoc_insertion_point(field_get:Edge.v2)
  return v2_ != NULL ? *v2_ : *default_instance_->v2_;
}
inline ::Point3D* Edge::mutable_v2() {
  set_has_v2();
  if (v2_ == NULL) {
    v2_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Edge.v2)
  return v2_;
}
inline ::Point3D* Edge::release_v2() {
  // @@protoc_insertion_point(field_release:Edge.v2)
  clear_has_v2();
  ::Point3D* temp = v2_;
  v2_ = NULL;
  return temp;
}
inline void Edge::set_allocated_v2(::Point3D* v2) {
  delete v2_;
  v2_ = v2;
  if (v2) {
    set_has_v2();
  } else {
    clear_has_v2();
  }
  // @@protoc_insertion_point(field_set_allocated:Edge.v2)
}

// optional .Properties prop = 3;
inline bool Edge::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_prop() {
  if (prop_ != NULL) prop_->::Properties::Clear();
  clear_has_prop();
}
inline const ::Properties& Edge::prop() const {
  // @@protoc_insertion_point(field_get:Edge.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::Properties* Edge::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::Properties;
  }
  // @@protoc_insertion_point(field_mutable:Edge.prop)
  return prop_;
}
inline ::Properties* Edge::release_prop() {
  // @@protoc_insertion_point(field_release:Edge.prop)
  clear_has_prop();
  ::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Edge::set_allocated_prop(::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Edge.prop)
}

// -------------------------------------------------------------------

// TriangleFace

// required .Point3D v1 = 1;
inline bool TriangleFace::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriangleFace::set_has_v1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriangleFace::clear_has_v1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriangleFace::clear_v1() {
  if (v1_ != NULL) v1_->::Point3D::Clear();
  clear_has_v1();
}
inline const ::Point3D& TriangleFace::v1() const {
  // @@protoc_insertion_point(field_get:TriangleFace.v1)
  return v1_ != NULL ? *v1_ : *default_instance_->v1_;
}
inline ::Point3D* TriangleFace::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:TriangleFace.v1)
  return v1_;
}
inline ::Point3D* TriangleFace::release_v1() {
  // @@protoc_insertion_point(field_release:TriangleFace.v1)
  clear_has_v1();
  ::Point3D* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_v1(::Point3D* v1) {
  delete v1_;
  v1_ = v1;
  if (v1) {
    set_has_v1();
  } else {
    clear_has_v1();
  }
  // @@protoc_insertion_point(field_set_allocated:TriangleFace.v1)
}

// required .Point3D v2 = 2;
inline bool TriangleFace::has_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriangleFace::set_has_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriangleFace::clear_has_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriangleFace::clear_v2() {
  if (v2_ != NULL) v2_->::Point3D::Clear();
  clear_has_v2();
}
inline const ::Point3D& TriangleFace::v2() const {
  // @@protoc_insertion_point(field_get:TriangleFace.v2)
  return v2_ != NULL ? *v2_ : *default_instance_->v2_;
}
inline ::Point3D* TriangleFace::mutable_v2() {
  set_has_v2();
  if (v2_ == NULL) {
    v2_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:TriangleFace.v2)
  return v2_;
}
inline ::Point3D* TriangleFace::release_v2() {
  // @@protoc_insertion_point(field_release:TriangleFace.v2)
  clear_has_v2();
  ::Point3D* temp = v2_;
  v2_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_v2(::Point3D* v2) {
  delete v2_;
  v2_ = v2;
  if (v2) {
    set_has_v2();
  } else {
    clear_has_v2();
  }
  // @@protoc_insertion_point(field_set_allocated:TriangleFace.v2)
}

// required .Point3D v3 = 3;
inline bool TriangleFace::has_v3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriangleFace::set_has_v3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriangleFace::clear_has_v3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriangleFace::clear_v3() {
  if (v3_ != NULL) v3_->::Point3D::Clear();
  clear_has_v3();
}
inline const ::Point3D& TriangleFace::v3() const {
  // @@protoc_insertion_point(field_get:TriangleFace.v3)
  return v3_ != NULL ? *v3_ : *default_instance_->v3_;
}
inline ::Point3D* TriangleFace::mutable_v3() {
  set_has_v3();
  if (v3_ == NULL) {
    v3_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:TriangleFace.v3)
  return v3_;
}
inline ::Point3D* TriangleFace::release_v3() {
  // @@protoc_insertion_point(field_release:TriangleFace.v3)
  clear_has_v3();
  ::Point3D* temp = v3_;
  v3_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_v3(::Point3D* v3) {
  delete v3_;
  v3_ = v3;
  if (v3) {
    set_has_v3();
  } else {
    clear_has_v3();
  }
  // @@protoc_insertion_point(field_set_allocated:TriangleFace.v3)
}

// optional .Properties prop = 4;
inline bool TriangleFace::has_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TriangleFace::set_has_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TriangleFace::clear_has_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TriangleFace::clear_prop() {
  if (prop_ != NULL) prop_->::Properties::Clear();
  clear_has_prop();
}
inline const ::Properties& TriangleFace::prop() const {
  // @@protoc_insertion_point(field_get:TriangleFace.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::Properties* TriangleFace::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::Properties;
  }
  // @@protoc_insertion_point(field_mutable:TriangleFace.prop)
  return prop_;
}
inline ::Properties* TriangleFace::release_prop() {
  // @@protoc_insertion_point(field_release:TriangleFace.prop)
  clear_has_prop();
  ::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void TriangleFace::set_allocated_prop(::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:TriangleFace.prop)
}

// -------------------------------------------------------------------

// Block

// required .Point3D v1 = 1;
inline bool Block::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_v1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_v1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_v1() {
  if (v1_ != NULL) v1_->::Point3D::Clear();
  clear_has_v1();
}
inline const ::Point3D& Block::v1() const {
  // @@protoc_insertion_point(field_get:Block.v1)
  return v1_ != NULL ? *v1_ : *default_instance_->v1_;
}
inline ::Point3D* Block::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Block.v1)
  return v1_;
}
inline ::Point3D* Block::release_v1() {
  // @@protoc_insertion_point(field_release:Block.v1)
  clear_has_v1();
  ::Point3D* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline void Block::set_allocated_v1(::Point3D* v1) {
  delete v1_;
  v1_ = v1;
  if (v1) {
    set_has_v1();
  } else {
    clear_has_v1();
  }
  // @@protoc_insertion_point(field_set_allocated:Block.v1)
}

// required .Point3D v2 = 2;
inline bool Block::has_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_v2() {
  if (v2_ != NULL) v2_->::Point3D::Clear();
  clear_has_v2();
}
inline const ::Point3D& Block::v2() const {
  // @@protoc_insertion_point(field_get:Block.v2)
  return v2_ != NULL ? *v2_ : *default_instance_->v2_;
}
inline ::Point3D* Block::mutable_v2() {
  set_has_v2();
  if (v2_ == NULL) {
    v2_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Block.v2)
  return v2_;
}
inline ::Point3D* Block::release_v2() {
  // @@protoc_insertion_point(field_release:Block.v2)
  clear_has_v2();
  ::Point3D* temp = v2_;
  v2_ = NULL;
  return temp;
}
inline void Block::set_allocated_v2(::Point3D* v2) {
  delete v2_;
  v2_ = v2;
  if (v2) {
    set_has_v2();
  } else {
    clear_has_v2();
  }
  // @@protoc_insertion_point(field_set_allocated:Block.v2)
}

// required .Point3D v3 = 3;
inline bool Block::has_v3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_v3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_v3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_v3() {
  if (v3_ != NULL) v3_->::Point3D::Clear();
  clear_has_v3();
}
inline const ::Point3D& Block::v3() const {
  // @@protoc_insertion_point(field_get:Block.v3)
  return v3_ != NULL ? *v3_ : *default_instance_->v3_;
}
inline ::Point3D* Block::mutable_v3() {
  set_has_v3();
  if (v3_ == NULL) {
    v3_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Block.v3)
  return v3_;
}
inline ::Point3D* Block::release_v3() {
  // @@protoc_insertion_point(field_release:Block.v3)
  clear_has_v3();
  ::Point3D* temp = v3_;
  v3_ = NULL;
  return temp;
}
inline void Block::set_allocated_v3(::Point3D* v3) {
  delete v3_;
  v3_ = v3;
  if (v3) {
    set_has_v3();
  } else {
    clear_has_v3();
  }
  // @@protoc_insertion_point(field_set_allocated:Block.v3)
}

// required .Point3D v4 = 4;
inline bool Block::has_v4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_v4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_v4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_v4() {
  if (v4_ != NULL) v4_->::Point3D::Clear();
  clear_has_v4();
}
inline const ::Point3D& Block::v4() const {
  // @@protoc_insertion_point(field_get:Block.v4)
  return v4_ != NULL ? *v4_ : *default_instance_->v4_;
}
inline ::Point3D* Block::mutable_v4() {
  set_has_v4();
  if (v4_ == NULL) {
    v4_ = new ::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:Block.v4)
  return v4_;
}
inline ::Point3D* Block::release_v4() {
  // @@protoc_insertion_point(field_release:Block.v4)
  clear_has_v4();
  ::Point3D* temp = v4_;
  v4_ = NULL;
  return temp;
}
inline void Block::set_allocated_v4(::Point3D* v4) {
  delete v4_;
  v4_ = v4;
  if (v4) {
    set_has_v4();
  } else {
    clear_has_v4();
  }
  // @@protoc_insertion_point(field_set_allocated:Block.v4)
}

// optional .Properties prop = 5;
inline bool Block::has_prop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Block::set_has_prop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Block::clear_has_prop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Block::clear_prop() {
  if (prop_ != NULL) prop_->::Properties::Clear();
  clear_has_prop();
}
inline const ::Properties& Block::prop() const {
  // @@protoc_insertion_point(field_get:Block.prop)
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::Properties* Block::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) {
    prop_ = new ::Properties;
  }
  // @@protoc_insertion_point(field_mutable:Block.prop)
  return prop_;
}
inline ::Properties* Block::release_prop() {
  // @@protoc_insertion_point(field_release:Block.prop)
  clear_has_prop();
  ::Properties* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Block::set_allocated_prop(::Properties* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Block.prop)
}

// -------------------------------------------------------------------

// MessageInfo

// required .MessageInfo.Type type = 1;
inline bool MessageInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::MessageInfo_Type MessageInfo::type() const {
  // @@protoc_insertion_point(field_get:MessageInfo.type)
  return static_cast< ::MessageInfo_Type >(type_);
}
inline void MessageInfo::set_type(::MessageInfo_Type value) {
  assert(::MessageInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MessageInfo.type)
}

// -------------------------------------------------------------------

// Header

// required int32 sizeOfData = 1;
inline bool Header::has_sizeofdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_sizeofdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_sizeofdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_sizeofdata() {
  sizeofdata_ = 0;
  clear_has_sizeofdata();
}
inline ::google::protobuf::int32 Header::sizeofdata() const {
  // @@protoc_insertion_point(field_get:Header.sizeOfData)
  return sizeofdata_;
}
inline void Header::set_sizeofdata(::google::protobuf::int32 value) {
  set_has_sizeofdata();
  sizeofdata_ = value;
  // @@protoc_insertion_point(field_set:Header.sizeOfData)
}

// required bool endOfData = 7;
inline bool Header::has_endofdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_endofdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_endofdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_endofdata() {
  endofdata_ = false;
  clear_has_endofdata();
}
inline bool Header::endofdata() const {
  // @@protoc_insertion_point(field_get:Header.endOfData)
  return endofdata_;
}
inline void Header::set_endofdata(bool value) {
  set_has_endofdata();
  endofdata_ = value;
  // @@protoc_insertion_point(field_set:Header.endOfData)
}

// -------------------------------------------------------------------

// DataPackage

// repeated .Point2D points2D = 1;
inline int DataPackage::points2d_size() const {
  return points2d_.size();
}
inline void DataPackage::clear_points2d() {
  points2d_.Clear();
}
inline const ::Point2D& DataPackage::points2d(int index) const {
  // @@protoc_insertion_point(field_get:DataPackage.points2D)
  return points2d_.Get(index);
}
inline ::Point2D* DataPackage::mutable_points2d(int index) {
  // @@protoc_insertion_point(field_mutable:DataPackage.points2D)
  return points2d_.Mutable(index);
}
inline ::Point2D* DataPackage::add_points2d() {
  // @@protoc_insertion_point(field_add:DataPackage.points2D)
  return points2d_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Point2D >*
DataPackage::mutable_points2d() {
  // @@protoc_insertion_point(field_mutable_list:DataPackage.points2D)
  return &points2d_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Point2D >&
DataPackage::points2d() const {
  // @@protoc_insertion_point(field_list:DataPackage.points2D)
  return points2d_;
}

// repeated .Point3D points3D = 2;
inline int DataPackage::points3d_size() const {
  return points3d_.size();
}
inline void DataPackage::clear_points3d() {
  points3d_.Clear();
}
inline const ::Point3D& DataPackage::points3d(int index) const {
  // @@protoc_insertion_point(field_get:DataPackage.points3D)
  return points3d_.Get(index);
}
inline ::Point3D* DataPackage::mutable_points3d(int index) {
  // @@protoc_insertion_point(field_mutable:DataPackage.points3D)
  return points3d_.Mutable(index);
}
inline ::Point3D* DataPackage::add_points3d() {
  // @@protoc_insertion_point(field_add:DataPackage.points3D)
  return points3d_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Point3D >*
DataPackage::mutable_points3d() {
  // @@protoc_insertion_point(field_mutable_list:DataPackage.points3D)
  return &points3d_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Point3D >&
DataPackage::points3d() const {
  // @@protoc_insertion_point(field_list:DataPackage.points3D)
  return points3d_;
}

// repeated .Vertex vertexes = 3;
inline int DataPackage::vertexes_size() const {
  return vertexes_.size();
}
inline void DataPackage::clear_vertexes() {
  vertexes_.Clear();
}
inline const ::Vertex& DataPackage::vertexes(int index) const {
  // @@protoc_insertion_point(field_get:DataPackage.vertexes)
  return vertexes_.Get(index);
}
inline ::Vertex* DataPackage::mutable_vertexes(int index) {
  // @@protoc_insertion_point(field_mutable:DataPackage.vertexes)
  return vertexes_.Mutable(index);
}
inline ::Vertex* DataPackage::add_vertexes() {
  // @@protoc_insertion_point(field_add:DataPackage.vertexes)
  return vertexes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Vertex >*
DataPackage::mutable_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:DataPackage.vertexes)
  return &vertexes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Vertex >&
DataPackage::vertexes() const {
  // @@protoc_insertion_point(field_list:DataPackage.vertexes)
  return vertexes_;
}

// repeated .Edge edges = 4;
inline int DataPackage::edges_size() const {
  return edges_.size();
}
inline void DataPackage::clear_edges() {
  edges_.Clear();
}
inline const ::Edge& DataPackage::edges(int index) const {
  // @@protoc_insertion_point(field_get:DataPackage.edges)
  return edges_.Get(index);
}
inline ::Edge* DataPackage::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:DataPackage.edges)
  return edges_.Mutable(index);
}
inline ::Edge* DataPackage::add_edges() {
  // @@protoc_insertion_point(field_add:DataPackage.edges)
  return edges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Edge >*
DataPackage::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:DataPackage.edges)
  return &edges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Edge >&
DataPackage::edges() const {
  // @@protoc_insertion_point(field_list:DataPackage.edges)
  return edges_;
}

// repeated .TriangleFace faces = 5;
inline int DataPackage::faces_size() const {
  return faces_.size();
}
inline void DataPackage::clear_faces() {
  faces_.Clear();
}
inline const ::TriangleFace& DataPackage::faces(int index) const {
  // @@protoc_insertion_point(field_get:DataPackage.faces)
  return faces_.Get(index);
}
inline ::TriangleFace* DataPackage::mutable_faces(int index) {
  // @@protoc_insertion_point(field_mutable:DataPackage.faces)
  return faces_.Mutable(index);
}
inline ::TriangleFace* DataPackage::add_faces() {
  // @@protoc_insertion_point(field_add:DataPackage.faces)
  return faces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TriangleFace >*
DataPackage::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:DataPackage.faces)
  return &faces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TriangleFace >&
DataPackage::faces() const {
  // @@protoc_insertion_point(field_list:DataPackage.faces)
  return faces_;
}

// repeated .Block blocks = 6;
inline int DataPackage::blocks_size() const {
  return blocks_.size();
}
inline void DataPackage::clear_blocks() {
  blocks_.Clear();
}
inline const ::Block& DataPackage::blocks(int index) const {
  // @@protoc_insertion_point(field_get:DataPackage.blocks)
  return blocks_.Get(index);
}
inline ::Block* DataPackage::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:DataPackage.blocks)
  return blocks_.Mutable(index);
}
inline ::Block* DataPackage::add_blocks() {
  // @@protoc_insertion_point(field_add:DataPackage.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Block >*
DataPackage::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:DataPackage.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Block >&
DataPackage::blocks() const {
  // @@protoc_insertion_point(field_list:DataPackage.blocks)
  return blocks_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MessageInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageInfo_Type>() {
  return ::MessageInfo_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structs_2eproto__INCLUDED
